

/*
 *  Copyright (C) 2005-2018 Team Kodi
 *  This file is part of Kodi - https://kodi.tv
 *
 *  SPDX-License-Identifier: GPL-2.0-or-later
 *  See LICENSES/README.md for more information.
 */

// ************************************************************************
// This file was generated by xbmc compile process. DO NOT EDIT!!
//  It was created by running the code generator on the spec file for
//  the module "xbmc" on the template file PythonSwig.template.cpp
// ************************************************************************



#include <Python.h>
#include <string>
#include "CompileInfo.h"
#include "interfaces/python/LanguageHook.h"
#include "interfaces/python/swig.h"
#include "interfaces/python/PyContext.h"


#if defined(TARGET_WINDOWS)
#  include <windows.h>
#endif

#include "interfaces/legacy/Player.h"
#include "interfaces/legacy/RenderCapture.h"
#include "interfaces/legacy/Keyboard.h"
#include "interfaces/legacy/ModuleXbmc.h"
#include "interfaces/legacy/Monitor.h"

using namespace XBMCAddon;
using namespace xbmc;

#if defined(__GNUG__)
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif


namespace PythonBindings
{

  //=========================================================================
  // These variables will hold the Python Type information for XBMCAddon::xbmc::Player
  TypeInfo TyXBMCAddon_xbmc_Player_Type(typeid(XBMCAddon::xbmc::Player));
  //=========================================================================

  //=========================================================================
  // These variables will hold the Python Type information for XBMCAddon::xbmc::RenderCapture
  TypeInfo TyXBMCAddon_xbmc_RenderCapture_Type(typeid(XBMCAddon::xbmc::RenderCapture));
  //=========================================================================

  //=========================================================================
  // These variables will hold the Python Type information for XBMCAddon::xbmc::InfoTagGame
  TypeInfo TyXBMCAddon_xbmc_InfoTagGame_Type(typeid(XBMCAddon::xbmc::InfoTagGame));
  //=========================================================================

  //=========================================================================
  // These variables will hold the Python Type information for XBMCAddon::xbmc::InfoTagMusic
  TypeInfo TyXBMCAddon_xbmc_InfoTagMusic_Type(typeid(XBMCAddon::xbmc::InfoTagMusic));
  //=========================================================================

  //=========================================================================
  // These variables will hold the Python Type information for XBMCAddon::xbmc::InfoTagPicture
  TypeInfo TyXBMCAddon_xbmc_InfoTagPicture_Type(typeid(XBMCAddon::xbmc::InfoTagPicture));
  //=========================================================================

  //=========================================================================
  // These variables will hold the Python Type information for XBMCAddon::xbmc::InfoTagRadioRDS
  TypeInfo TyXBMCAddon_xbmc_InfoTagRadioRDS_Type(typeid(XBMCAddon::xbmc::InfoTagRadioRDS));
  //=========================================================================

  //=========================================================================
  // These variables will hold the Python Type information for XBMCAddon::xbmc::Actor
  TypeInfo TyXBMCAddon_xbmc_Actor_Type(typeid(XBMCAddon::xbmc::Actor));
  //=========================================================================

  //=========================================================================
  // These variables will hold the Python Type information for XBMCAddon::xbmc::VideoStreamDetail
  TypeInfo TyXBMCAddon_xbmc_VideoStreamDetail_Type(typeid(XBMCAddon::xbmc::VideoStreamDetail));
  //=========================================================================

  //=========================================================================
  // These variables will hold the Python Type information for XBMCAddon::xbmc::AudioStreamDetail
  TypeInfo TyXBMCAddon_xbmc_AudioStreamDetail_Type(typeid(XBMCAddon::xbmc::AudioStreamDetail));
  //=========================================================================

  //=========================================================================
  // These variables will hold the Python Type information for XBMCAddon::xbmc::SubtitleStreamDetail
  TypeInfo TyXBMCAddon_xbmc_SubtitleStreamDetail_Type(typeid(XBMCAddon::xbmc::SubtitleStreamDetail));
  //=========================================================================

  //=========================================================================
  // These variables will hold the Python Type information for XBMCAddon::xbmc::InfoTagVideo
  TypeInfo TyXBMCAddon_xbmc_InfoTagVideo_Type(typeid(XBMCAddon::xbmc::InfoTagVideo));
  //=========================================================================

  //=========================================================================
  // These variables will hold the Python Type information for XBMCAddon::xbmc::Keyboard
  TypeInfo TyXBMCAddon_xbmc_Keyboard_Type(typeid(XBMCAddon::xbmc::Keyboard));
  //=========================================================================

  //=========================================================================
  // These variables will hold the Python Type information for XBMCAddon::xbmc::PlayList
  TypeInfo TyXBMCAddon_xbmc_PlayList_Type(typeid(XBMCAddon::xbmc::PlayList));
  //=========================================================================

  //=========================================================================
  // These variables will hold the Python Type information for XBMCAddon::xbmc::Monitor
  TypeInfo TyXBMCAddon_xbmc_Monitor_Type(typeid(XBMCAddon::xbmc::Monitor));
  //=========================================================================

  //=========================================================================
  // These variables define the type XBMCAddon::xbmcgui::ListItem from another module
  extern TypeInfo TyXBMCAddon_xbmcgui_ListItem_Type;
  //=========================================================================

  //=========================================================================
  // These variables define the type XBMCAddon::xbmc::PlayListItem from another module
  extern TypeInfo TyXBMCAddon_xbmc_PlayListItem_Type;
  //=========================================================================



  //=========================================================================
  // This class is the Director for XBMCAddon::xbmc::Player.
  // It provides the "reverse bridge" from C++ to Python to support
  // cross-language polymorphism.
  //=========================================================================
  class XBMCAddon_xbmc_Player_Director : public Director, public XBMCAddon::xbmc::Player
  {
    public:

      inline XBMCAddon_xbmc_Player_Director() : XBMCAddon::xbmc::Player() { } 

      virtual void  onPlayBackStarted(  )
      { 
        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onPlayBackStarted","()");
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

      virtual void  onAVStarted(  )
      { 
        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onAVStarted","()");
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

      virtual void  onAVChange(  )
      { 
        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onAVChange","()");
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

      virtual void  onPlayBackEnded(  )
      { 
        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onPlayBackEnded","()");
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

      virtual void  onPlayBackStopped(  )
      { 
        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onPlayBackStopped","()");
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

      virtual void  onPlayBackError(  )
      { 
        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onPlayBackError","()");
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

      virtual void  onPlayBackPaused(  )
      { 
        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onPlayBackPaused","()");
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

      virtual void  onPlayBackResumed(  )
      { 
        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onPlayBackResumed","()");
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

      virtual void  onQueueNextItem(  )
      { 
        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onQueueNextItem","()");
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

      virtual void  onPlayBackSpeedChanged(  int  speed  )
      { 
        PyObject* pyspeed = NULL;
        pyspeed = Py_BuildValue("i", speed);
        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onPlayBackSpeedChanged","(O)", pyspeed );
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

      virtual void  onPlayBackSeek(  int  time,  int  seekOffset  )
      { 
        PyObject* pytime = NULL;
        pytime = Py_BuildValue("i", time);
        PyObject* pyseekOffset = NULL;
        pyseekOffset = Py_BuildValue("i", seekOffset);
        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onPlayBackSeek","(OO)", pytime , pyseekOffset );
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

      virtual void  onPlayBackSeekChapter(  int  chapter  )
      { 
        PyObject* pychapter = NULL;
        pychapter = Py_BuildValue("i", chapter);
        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onPlayBackSeekChapter","(O)", pychapter );
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

  };

  //=========================================================================
  // This class is the Director for XBMCAddon::xbmc::Monitor.
  // It provides the "reverse bridge" from C++ to Python to support
  // cross-language polymorphism.
  //=========================================================================
  class XBMCAddon_xbmc_Monitor_Director : public Director, public XBMCAddon::xbmc::Monitor
  {
    public:

      inline XBMCAddon_xbmc_Monitor_Director() : XBMCAddon::xbmc::Monitor() { } 

      virtual void  onSettingsChanged(  )
      { 
        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onSettingsChanged","()");
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

      virtual void  onScreensaverActivated(  )
      { 
        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onScreensaverActivated","()");
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

      virtual void  onScreensaverDeactivated(  )
      { 
        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onScreensaverDeactivated","()");
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

      virtual void  onDPMSActivated(  )
      { 
        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onDPMSActivated","()");
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

      virtual void  onDPMSDeactivated(  )
      { 
        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onDPMSDeactivated","()");
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

      virtual void  onScanStarted(  XBMCAddon::String const  library  )
      { 
        PyObject* pylibrary = NULL;
        pylibrary = PyUnicode_DecodeUTF8(library.c_str(),library.size(),"surrogateescape");

        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onScanStarted","(O)", pylibrary );
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

      virtual void  onScanFinished(  XBMCAddon::String const  library  )
      { 
        PyObject* pylibrary = NULL;
        pylibrary = PyUnicode_DecodeUTF8(library.c_str(),library.size(),"surrogateescape");

        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onScanFinished","(O)", pylibrary );
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

      virtual void  onCleanStarted(  XBMCAddon::String const  library  )
      { 
        PyObject* pylibrary = NULL;
        pylibrary = PyUnicode_DecodeUTF8(library.c_str(),library.size(),"surrogateescape");

        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onCleanStarted","(O)", pylibrary );
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

      virtual void  onCleanFinished(  XBMCAddon::String const  library  )
      { 
        PyObject* pylibrary = NULL;
        pylibrary = PyUnicode_DecodeUTF8(library.c_str(),library.size(),"surrogateescape");

        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onCleanFinished","(O)", pylibrary );
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

      virtual void  onNotification(  XBMCAddon::String const  sender,  XBMCAddon::String const  method,  XBMCAddon::String const  data  )
      { 
        PyObject* pysender = NULL;
        pysender = PyUnicode_DecodeUTF8(sender.c_str(),sender.size(),"surrogateescape");

        PyObject* pymethod = NULL;
        pymethod = PyUnicode_DecodeUTF8(method.c_str(),method.size(),"surrogateescape");

        PyObject* pydata = NULL;
        pydata = PyUnicode_DecodeUTF8(data.c_str(),data.size(),"surrogateescape");

        XBMCAddon::Python::PyContext pyContext;
        PyObject_CallMethod(self,"onNotification","(OOO)", pysender , pymethod , pydata );
        if (PyErr_Occurred())
          throw PythonBindings::PythonToCppException();
      }

  };

  static PyObject* xbmc_log (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "msg",
          "level",
          NULL};

    char * msg  = nullptr;
    int  level  = lLOGDEBUG;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "s|i",
       const_cast<char**>(keywords),
         &msg,
         &level
       ))
    {
      return NULL;
    }


    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      XBMCAddon::xbmc::log(  msg,  level  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::log\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::log\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_shutdown (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      XBMCAddon::xbmc::shutdown(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::shutdown\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::shutdown\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_restart (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      XBMCAddon::xbmc::restart(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::restart\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::restart\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_executescript (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "script",
          NULL};

    char * script  = nullptr;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "s",
       const_cast<char**>(keywords),
         &script
       ))
    {
      return NULL;
    }


    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      XBMCAddon::xbmc::executescript(  script  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::executescript\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::executescript\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_executebuiltin (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "function",
          "wait",
          NULL};

    char * function  = nullptr;
    bool  wait  = false;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "s|b",
       const_cast<char**>(keywords),
         &function,
         &wait
       ))
    {
      return NULL;
    }


    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      XBMCAddon::xbmc::executebuiltin(  function,  wait  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::executebuiltin\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::executebuiltin\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_executeJSONRPC (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "jsonrpccommand",
          NULL};

    char * jsonrpccommand  = nullptr;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "s",
       const_cast<char**>(keywords),
         &jsonrpccommand
       ))
    {
      return NULL;
    }

    XBMCAddon::String  apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = XBMCAddon::xbmc::executeJSONRPC(  jsonrpccommand  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::executeJSONRPC\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::executeJSONRPC\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_sleep (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "timemillis",
          NULL};

    long  timemillis ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "l",
       const_cast<char**>(keywords),
         &timemillis
       ))
    {
      return NULL;
    }


    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      XBMCAddon::xbmc::sleep(  timemillis  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::sleep\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::sleep\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_getLocalizedString (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "id",
          NULL};

    int  id ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &id
       ))
    {
      return NULL;
    }

    XBMCAddon::String  apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = XBMCAddon::xbmc::getLocalizedString(  id  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::getLocalizedString\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::getLocalizedString\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_getSkinDir (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = XBMCAddon::xbmc::getSkinDir(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::getSkinDir\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::getSkinDir\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_getLanguage (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "format",
          "region",
          NULL};

    int  format  = CLangCodeExpander::ENGLISH_NAME;
    bool  region  = false;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "|ib",
       const_cast<char**>(keywords),
         &format,
         &region
       ))
    {
      return NULL;
    }

    XBMCAddon::String  apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = XBMCAddon::xbmc::getLanguage(  format,  region  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::getLanguage\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::getLanguage\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_getIPAddress (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = XBMCAddon::xbmc::getIPAddress(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::getIPAddress\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::getIPAddress\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_getDVDState (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    long  apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = XBMCAddon::xbmc::getDVDState(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::getDVDState\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::getDVDState\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyLong_FromLong(apiResult);

    return result; 
  } 

  static PyObject* xbmc_getFreeMem (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    long  apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = XBMCAddon::xbmc::getFreeMem(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::getFreeMem\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::getFreeMem\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyLong_FromLong(apiResult);

    return result; 
  } 

  static PyObject* xbmc_getInfoLabel (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "cLine",
          NULL};

    char * cLine  = nullptr;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "s",
       const_cast<char**>(keywords),
         &cLine
       ))
    {
      return NULL;
    }

    XBMCAddon::String  apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = XBMCAddon::xbmc::getInfoLabel(  cLine  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::getInfoLabel\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::getInfoLabel\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_getInfoImage (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "infotag",
          NULL};

    char * infotag  = nullptr;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "s",
       const_cast<char**>(keywords),
         &infotag
       ))
    {
      return NULL;
    }

    XBMCAddon::String  apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = XBMCAddon::xbmc::getInfoImage(  infotag  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::getInfoImage\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::getInfoImage\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_playSFX (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "filename",
          "useCached",
          NULL};

    char * filename  = nullptr;
    bool  useCached  = true;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "s|b",
       const_cast<char**>(keywords),
         &filename,
         &useCached
       ))
    {
      return NULL;
    }


    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      XBMCAddon::xbmc::playSFX(  filename,  useCached  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::playSFX\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::playSFX\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_stopSFX (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      XBMCAddon::xbmc::stopSFX(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::stopSFX\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::stopSFX\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_enableNavSounds (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "yesNo",
          NULL};

    bool  yesNo ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "b",
       const_cast<char**>(keywords),
         &yesNo
       ))
    {
      return NULL;
    }


    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      XBMCAddon::xbmc::enableNavSounds(  yesNo  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::enableNavSounds\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::enableNavSounds\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_getCondVisibility (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "condition",
          NULL};

    char * condition  = nullptr;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "s",
       const_cast<char**>(keywords),
         &condition
       ))
    {
      return NULL;
    }

    bool  apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = XBMCAddon::xbmc::getCondVisibility(  condition  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::getCondVisibility\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::getCondVisibility\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = apiResult ? Py_True : Py_False; Py_INCREF(result);

    return result; 
  } 

  static PyObject* xbmc_getGlobalIdleTime (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = XBMCAddon::xbmc::getGlobalIdleTime(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::getGlobalIdleTime\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::getGlobalIdleTime\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_getCacheThumbName (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "path",
          NULL};

    std::string  path ;
    PyObject* pypath = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pypath
       ))
    {
      return NULL;
    }

    XBMCAddon::String  apiResult;
    try
    {
      if (pypath) PyXBMCGetUnicodeString(path,pypath,false,"path","XBMCAddon::xbmc::getCacheThumbName"); 

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = XBMCAddon::xbmc::getCacheThumbName(  path  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::getCacheThumbName\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::getCacheThumbName\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_getCleanMovieTitle (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "path",
          "usefoldername",
          NULL};

    std::string  path ;
    PyObject* pypath = NULL;
    bool  usefoldername  = false;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O|b",
       const_cast<char**>(keywords),
         &pypath,
         &usefoldername
       ))
    {
      return NULL;
    }

    Tuple< XBMCAddon::String ,XBMCAddon::String  >  apiResult;
    try
    {
      if (pypath) PyXBMCGetUnicodeString(path,pypath,false,"path","XBMCAddon::xbmc::getCleanMovieTitle"); 

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = XBMCAddon::xbmc::getCleanMovieTitle(  path,  usefoldername  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::getCleanMovieTitle\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::getCleanMovieTitle\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    
    int vecSize = apiResult.GetNumValuesSet();
    result = PyTuple_New(vecSize);
    {
      PyObject* pyentry1; 

      if (vecSize > 0)
      {
        std::string & entry1 = apiResult.first();
        {
          pyentry1 = PyUnicode_DecodeUTF8(entry1.c_str(),entry1.size(),"surrogateescape");

        }
        PyTuple_SetItem(result, 0, pyentry1);
      }


      if (vecSize > 1)
      {
        std::string & entry1 = apiResult.second();
        {
          pyentry1 = PyUnicode_DecodeUTF8(entry1.c_str(),entry1.size(),"surrogateescape");

        }
        PyTuple_SetItem(result, 1, pyentry1);
      }

    }

    return result; 
  } 

  static PyObject* xbmc_getRegion (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "id",
          NULL};

    char * id  = nullptr;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "s",
       const_cast<char**>(keywords),
         &id
       ))
    {
      return NULL;
    }

    XBMCAddon::String  apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = XBMCAddon::xbmc::getRegion(  id  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::getRegion\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::getRegion\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_getSupportedMedia (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "mediaType",
          NULL};

    char * mediaType  = nullptr;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "s",
       const_cast<char**>(keywords),
         &mediaType
       ))
    {
      return NULL;
    }

    XBMCAddon::String  apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = XBMCAddon::xbmc::getSupportedMedia(  mediaType  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::getSupportedMedia\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::getSupportedMedia\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_skinHasImage (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "image",
          NULL};

    char * image  = nullptr;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "s",
       const_cast<char**>(keywords),
         &image
       ))
    {
      return NULL;
    }

    bool  apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = XBMCAddon::xbmc::skinHasImage(  image  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::skinHasImage\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::skinHasImage\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = apiResult ? Py_True : Py_False; Py_INCREF(result);

    return result; 
  } 

  static PyObject* xbmc_startServer (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "iTyp",
          "bStart",
          NULL};

    int  iTyp ;
    bool  bStart ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "ib",
       const_cast<char**>(keywords),
         &iTyp,
         &bStart
       ))
    {
      return NULL;
    }

    bool  apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = XBMCAddon::xbmc::startServer(  iTyp,  bStart  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::startServer\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::startServer\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = apiResult ? Py_True : Py_False; Py_INCREF(result);

    return result; 
  } 

  static PyObject* xbmc_audioSuspend (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      XBMCAddon::xbmc::audioSuspend(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::audioSuspend\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::audioSuspend\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_audioResume (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      XBMCAddon::xbmc::audioResume(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::audioResume\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::audioResume\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_getUserAgent (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = XBMCAddon::xbmc::getUserAgent(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::getUserAgent\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::getUserAgent\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_convertLanguage (PyObject* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "language",
          "format",
          NULL};

    char * language  = nullptr;
    int  format ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "si",
       const_cast<char**>(keywords),
         &language,
         &format
       ))
    {
      return NULL;
    }

    XBMCAddon::String  apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = XBMCAddon::xbmc::convertLanguage(  language,  format  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::convertLanguage\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::convertLanguage\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_New (PyTypeObject* pytype  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::xbmc::Player * apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = (&(TyXBMCAddon_xbmc_Player_Type.pythonType) != pytype) ? new XBMCAddon_xbmc_Player_Director() : new XBMCAddon::xbmc::Player(  );
      prepareForReturn(apiResult);
    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"new XBMCAddon::xbmc::Player\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"new XBMCAddon::xbmc::Player\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,pytype,false);
    if (&(TyXBMCAddon_xbmc_Player_Type.pythonType) != pytype)
      ((XBMCAddon_xbmc_Player_Director*)apiResult)->setPyObjectForDirector(result);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_play (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "item",
          "listitem",
          "windowed",
          "startpos",
          NULL};

    Alternative< XBMCAddon::String ,PlayList const * >  item  = Player::defaultPlayParameter;
    PyObject* pyitem = NULL;
    XBMCAddon::xbmcgui::ListItem * listitem  = NULL;
    PyObject* pylistitem = NULL;
    bool  windowed  = false;
    int  startpos  = -1;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "|OObi",
       const_cast<char**>(keywords),
         &pyitem,
         &pylistitem,
         &windowed,
         &startpos
       ))
    {
      return NULL;
    }


    try
    {
      
    {
      // we need to check the parameter type and see if it matches
      PyObject *pyentry_1 = pyitem;
      try
      {
        std::string  entry0_1;
        if (pyentry_1) PyXBMCGetUnicodeString(entry0_1,pyentry_1,false,"entry0_1","play");
        item.former() = entry0_1;
      }
      catch (const XBMCAddon::WrongTypeException&)
      {
        try
        {
          PlayList * entry1_1;
          entry1_1 = (PlayList *)retrieveApiInstance(pyentry_1,"p.PlayList","XBMCAddon::xbmc::","play");
          item.later() = entry1_1;
        }
        catch (const XBMCAddon::WrongTypeException&)
        {
          throw XBMCAddon::WrongTypeException("Failed to convert to input type to either a "
                                              "std::string or a "
                                              "p.PlayList" );
        }
      }
    } 
      listitem = (XBMCAddon::xbmcgui::ListItem *)retrieveApiInstance(pylistitem,"p.XBMCAddon::xbmcgui::ListItem","XBMCAddon::xbmc::","play"); 

      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"play","XBMCAddon::xbmc::Player"))-> play(  item,  listitem,  windowed,  startpos  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"play\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"play\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_stop (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"stop","XBMCAddon::xbmc::Player"))-> stop(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"stop\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"stop\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_pause (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"pause","XBMCAddon::xbmc::Player"))-> pause(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"pause\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"pause\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_playnext (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"playnext","XBMCAddon::xbmc::Player"))-> playnext(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"playnext\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"playnext\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_playprevious (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"playprevious","XBMCAddon::xbmc::Player"))-> playprevious(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"playprevious\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"playprevious\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_playselected (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "selected",
          NULL};

    int  selected ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &selected
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"playselected","XBMCAddon::xbmc::Player"))-> playselected(  selected  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"playselected\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"playselected\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_launchURI(PyHolder* self, PyObject* args, PyObject* kwds) {
      XBMC_TRACE;

      static const char* keywords[] = {
            "uri",
            NULL
      };
      PyObject* pyitem = NULL;
      if (!PyArg_ParseTupleAndKeywords(
          args,
          kwds,
          "O",
          const_cast<char**>(keywords),
          &pyitem
      ))
      {
          return NULL;
      }

      std::string  uri;
      PyObject* pyentry_1 = pyitem;
      if (pyentry_1) PyXBMCGetUnicodeString(uri, pyentry_1, false, "uri", "launchURI");

      try
      {
          ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self, &TyXBMCAddon_xbmc_Player_Type, "launchURI", "XBMCAddon::xbmc::Player"))->launchURI(uri);
      }
      catch (const XBMCAddon::WrongTypeException& e)
      {
          CLog::Log(LOGERROR, "EXCEPTION: {}", e.GetExMessage());
          PyErr_SetString(PyExc_TypeError, e.GetExMessage());
          return NULL;
      }
      catch (const XbmcCommons::Exception& e)
      {
          CLog::Log(LOGERROR, "EXCEPTION: {}", e.GetExMessage());
          PyErr_SetString(PyExc_RuntimeError, e.GetExMessage());
          return NULL;
      }
      catch (...)
      {
          CLog::Log(LOGERROR, "EXCEPTION: Unknown exception thrown from the call \"launchURI\"");
          PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"launchURI\"");
          return NULL;
      }

      PyObject* result = Py_None;

      // transform the result
      Py_INCREF(Py_None);
      result = Py_None;

      return result;
  }

  static PyObject* xbmc_XBMCAddon_xbmc_Player_onPlayBackStarted (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"onPlayBackStarted","XBMCAddon::xbmc::Player"))-> XBMCAddon::xbmc::Player::onPlayBackStarted(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onPlayBackStarted\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onPlayBackStarted\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_onAVStarted (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"onAVStarted","XBMCAddon::xbmc::Player"))-> XBMCAddon::xbmc::Player::onAVStarted(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onAVStarted\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onAVStarted\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_onAVChange (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"onAVChange","XBMCAddon::xbmc::Player"))-> XBMCAddon::xbmc::Player::onAVChange(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onAVChange\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onAVChange\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_onPlayBackEnded (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"onPlayBackEnded","XBMCAddon::xbmc::Player"))-> XBMCAddon::xbmc::Player::onPlayBackEnded(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onPlayBackEnded\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onPlayBackEnded\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_onPlayBackStopped (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"onPlayBackStopped","XBMCAddon::xbmc::Player"))-> XBMCAddon::xbmc::Player::onPlayBackStopped(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onPlayBackStopped\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onPlayBackStopped\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_onPlayBackError (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"onPlayBackError","XBMCAddon::xbmc::Player"))-> XBMCAddon::xbmc::Player::onPlayBackError(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onPlayBackError\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onPlayBackError\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_onPlayBackPaused (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"onPlayBackPaused","XBMCAddon::xbmc::Player"))-> XBMCAddon::xbmc::Player::onPlayBackPaused(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onPlayBackPaused\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onPlayBackPaused\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_onPlayBackResumed (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"onPlayBackResumed","XBMCAddon::xbmc::Player"))-> XBMCAddon::xbmc::Player::onPlayBackResumed(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onPlayBackResumed\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onPlayBackResumed\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_onQueueNextItem (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"onQueueNextItem","XBMCAddon::xbmc::Player"))-> XBMCAddon::xbmc::Player::onQueueNextItem(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onQueueNextItem\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onQueueNextItem\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_onPlayBackSpeedChanged (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "speed",
          NULL};

    int  speed ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &speed
       ))
    {
      return NULL;
    }


    try
    {

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"onPlayBackSpeedChanged","XBMCAddon::xbmc::Player"))-> XBMCAddon::xbmc::Player::onPlayBackSpeedChanged(  speed  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onPlayBackSpeedChanged\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onPlayBackSpeedChanged\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_onPlayBackSeek (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "time",
          "seekOffset",
          NULL};

    int  time ;
    int  seekOffset ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "ii",
       const_cast<char**>(keywords),
         &time,
         &seekOffset
       ))
    {
      return NULL;
    }


    try
    {

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"onPlayBackSeek","XBMCAddon::xbmc::Player"))-> XBMCAddon::xbmc::Player::onPlayBackSeek(  time,  seekOffset  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onPlayBackSeek\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onPlayBackSeek\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_onPlayBackSeekChapter (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "chapter",
          NULL};

    int  chapter ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &chapter
       ))
    {
      return NULL;
    }


    try
    {

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"onPlayBackSeekChapter","XBMCAddon::xbmc::Player"))-> XBMCAddon::xbmc::Player::onPlayBackSeekChapter(  chapter  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onPlayBackSeekChapter\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onPlayBackSeekChapter\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_isPlaying (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    bool  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"isPlaying","XBMCAddon::xbmc::Player"))-> isPlaying(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"isPlaying\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"isPlaying\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = apiResult ? Py_True : Py_False; Py_INCREF(result);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_isPlayingAudio (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    bool  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"isPlayingAudio","XBMCAddon::xbmc::Player"))-> isPlayingAudio(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"isPlayingAudio\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"isPlayingAudio\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = apiResult ? Py_True : Py_False; Py_INCREF(result);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_isPlayingVideo (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    bool  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"isPlayingVideo","XBMCAddon::xbmc::Player"))-> isPlayingVideo(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"isPlayingVideo\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"isPlayingVideo\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = apiResult ? Py_True : Py_False; Py_INCREF(result);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_isPlayingRDS (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    bool  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"isPlayingRDS","XBMCAddon::xbmc::Player"))-> isPlayingRDS(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"isPlayingRDS\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"isPlayingRDS\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = apiResult ? Py_True : Py_False; Py_INCREF(result);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_isExternalPlayer (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    bool  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"isExternalPlayer","XBMCAddon::xbmc::Player"))-> isExternalPlayer(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"isExternalPlayer\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"isExternalPlayer\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = apiResult ? Py_True : Py_False; Py_INCREF(result);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_getPlayingFile (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"getPlayingFile","XBMCAddon::xbmc::Player"))-> getPlayingFile(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getPlayingFile\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getPlayingFile\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_getPlayingItem (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::xbmcgui::ListItem * apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"getPlayingItem","XBMCAddon::xbmc::Player"))-> getPlayingItem(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getPlayingItem\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getPlayingItem\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,true);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_getTime (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    double  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"getTime","XBMCAddon::xbmc::Player"))-> getTime(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getTime\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getTime\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyFloat_FromDouble(apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_seekTime (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "seekTime",
          NULL};

    double  seekTime ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "d",
       const_cast<char**>(keywords),
         &seekTime
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"seekTime","XBMCAddon::xbmc::Player"))-> seekTime(  seekTime  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"seekTime\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"seekTime\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_setSubtitles (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "subtitleFile",
          NULL};

    char * subtitleFile  = nullptr;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "s",
       const_cast<char**>(keywords),
         &subtitleFile
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"setSubtitles","XBMCAddon::xbmc::Player"))-> setSubtitles(  subtitleFile  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setSubtitles\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setSubtitles\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_showSubtitles (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "bVisible",
          NULL};

    bool  bVisible ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "b",
       const_cast<char**>(keywords),
         &bVisible
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"showSubtitles","XBMCAddon::xbmc::Player"))-> showSubtitles(  bVisible  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"showSubtitles\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"showSubtitles\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_getSubtitles (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"getSubtitles","XBMCAddon::xbmc::Player"))-> getSubtitles(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getSubtitles\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getSubtitles\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_getAvailableSubtitleStreams (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    std::vector< XBMCAddon::String  >  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"getAvailableSubtitleStreams","XBMCAddon::xbmc::Player"))-> getAvailableSubtitleStreams(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getAvailableSubtitleStreams\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getAvailableSubtitleStreams\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    
      result = PyList_New(0);

      for (std::vector<XBMCAddon::String >::iterator iter = apiResult.begin(); iter != apiResult.end(); ++iter)
      {
        PyObject* pyentry1;
        pyentry1 = PyUnicode_DecodeUTF8((*iter).c_str(),(*iter).size(),"surrogateescape");

        PyList_Append(result, pyentry1);
        Py_DECREF(pyentry1);
      }



    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_setSubtitleStream (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "iStream",
          NULL};

    int  iStream ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &iStream
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"setSubtitleStream","XBMCAddon::xbmc::Player"))-> setSubtitleStream(  iStream  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setSubtitleStream\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setSubtitleStream\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_updateInfoTag (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "item",
          NULL};

    XBMCAddon::xbmcgui::ListItem * item  = nullptr;
    PyObject* pyitem = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyitem
       ))
    {
      return NULL;
    }


    try
    {
      item = (XBMCAddon::xbmcgui::ListItem *)retrieveApiInstance(pyitem,"p.XBMCAddon::xbmcgui::ListItem","XBMCAddon::xbmc::","updateInfoTag"); 

      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"updateInfoTag","XBMCAddon::xbmc::Player"))-> updateInfoTag(  item  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"updateInfoTag\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"updateInfoTag\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_getVideoInfoTag (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    InfoTagVideo * apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"getVideoInfoTag","XBMCAddon::xbmc::Player"))-> getVideoInfoTag(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getVideoInfoTag\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getVideoInfoTag\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,true);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_getMusicInfoTag (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    InfoTagMusic * apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"getMusicInfoTag","XBMCAddon::xbmc::Player"))-> getMusicInfoTag(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getMusicInfoTag\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getMusicInfoTag\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,true);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_getRadioRDSInfoTag (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    InfoTagRadioRDS * apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"getRadioRDSInfoTag","XBMCAddon::xbmc::Player"))-> getRadioRDSInfoTag(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getRadioRDSInfoTag\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getRadioRDSInfoTag\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,true);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_getTotalTime (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    double  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"getTotalTime","XBMCAddon::xbmc::Player"))-> getTotalTime(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getTotalTime\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getTotalTime\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyFloat_FromDouble(apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_getAvailableAudioStreams (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    std::vector< XBMCAddon::String  >  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"getAvailableAudioStreams","XBMCAddon::xbmc::Player"))-> getAvailableAudioStreams(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getAvailableAudioStreams\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getAvailableAudioStreams\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    
      result = PyList_New(0);

      for (std::vector<XBMCAddon::String >::iterator iter = apiResult.begin(); iter != apiResult.end(); ++iter)
      {
        PyObject* pyentry1;
        pyentry1 = PyUnicode_DecodeUTF8((*iter).c_str(),(*iter).size(),"surrogateescape");

        PyList_Append(result, pyentry1);
        Py_DECREF(pyentry1);
      }



    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_setAudioStream (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "iStream",
          NULL};

    int  iStream ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &iStream
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"setAudioStream","XBMCAddon::xbmc::Player"))-> setAudioStream(  iStream  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setAudioStream\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setAudioStream\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_getAvailableVideoStreams (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    std::vector< XBMCAddon::String  >  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"getAvailableVideoStreams","XBMCAddon::xbmc::Player"))-> getAvailableVideoStreams(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getAvailableVideoStreams\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getAvailableVideoStreams\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    
      result = PyList_New(0);

      for (std::vector<XBMCAddon::String >::iterator iter = apiResult.begin(); iter != apiResult.end(); ++iter)
      {
        PyObject* pyentry1;
        pyentry1 = PyUnicode_DecodeUTF8((*iter).c_str(),(*iter).size(),"surrogateescape");

        PyList_Append(result, pyentry1);
        Py_DECREF(pyentry1);
      }



    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Player_setVideoStream (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "iStream",
          NULL};

    int  iStream ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &iStream
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"setVideoStream","XBMCAddon::xbmc::Player"))-> setVideoStream(  iStream  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setVideoStream\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setVideoStream\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_RenderCapture_New (PyTypeObject* pytype  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::xbmc::RenderCapture * apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = new XBMCAddon::xbmc::RenderCapture(  );
      prepareForReturn(apiResult);
    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"new XBMCAddon::xbmc::RenderCapture\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"new XBMCAddon::xbmc::RenderCapture\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,pytype,false);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_RenderCapture_getWidth (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::RenderCapture*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_RenderCapture_Type,"getWidth","XBMCAddon::xbmc::RenderCapture"))-> getWidth(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getWidth\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getWidth\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_RenderCapture_getHeight (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::RenderCapture*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_RenderCapture_Type,"getHeight","XBMCAddon::xbmc::RenderCapture"))-> getHeight(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getHeight\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getHeight\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_RenderCapture_getAspectRatio (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    float  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::RenderCapture*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_RenderCapture_Type,"getAspectRatio","XBMCAddon::xbmc::RenderCapture"))-> getAspectRatio(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getAspectRatio\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getAspectRatio\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("f", static_cast<double>(apiResult));

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_RenderCapture_getImageFormat (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    char const * apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::RenderCapture*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_RenderCapture_Type,"getImageFormat","XBMCAddon::xbmc::RenderCapture"))-> getImageFormat(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getImageFormat\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getImageFormat\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_FromString(apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_RenderCapture_getImage (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "msecs",
          NULL};

    unsigned int  msecs  = 0;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "|I",
       const_cast<char**>(keywords),
         &msecs
       ))
    {
      return NULL;
    }

    XbmcCommons::Buffer  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::RenderCapture*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_RenderCapture_Type,"getImage","XBMCAddon::xbmc::RenderCapture"))-> getImage(  msecs  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getImage\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getImage\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyByteArray_FromStringAndSize((char*)apiResult.curPosition(),apiResult.remaining());

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_RenderCapture_capture (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "width",
          "height",
          NULL};

    int  width ;
    int  height ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "ii",
       const_cast<char**>(keywords),
         &width,
         &height
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::RenderCapture*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_RenderCapture_Type,"capture","XBMCAddon::xbmc::RenderCapture"))-> capture(  width,  height  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"capture\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"capture\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagGame_New (PyTypeObject* pytype  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "offscreen",
          NULL};

    bool  offscreen  = false;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "|b",
       const_cast<char**>(keywords),
         &offscreen
       ))
    {
      return NULL;
    }

    XBMCAddon::xbmc::InfoTagGame * apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = new XBMCAddon::xbmc::InfoTagGame(  offscreen  );
      prepareForReturn(apiResult);
    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"new XBMCAddon::xbmc::InfoTagGame\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"new XBMCAddon::xbmc::InfoTagGame\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,pytype,false);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagGame_getTitle (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagGame*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagGame_Type,"getTitle","XBMCAddon::xbmc::InfoTagGame"))-> getTitle(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getTitle\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getTitle\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagGame_getPlatform (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagGame*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagGame_Type,"getPlatform","XBMCAddon::xbmc::InfoTagGame"))-> getPlatform(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getPlatform\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getPlatform\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagGame_getGenres (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    std::vector< XBMCAddon::String  >  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagGame*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagGame_Type,"getGenres","XBMCAddon::xbmc::InfoTagGame"))-> getGenres(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getGenres\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getGenres\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    
      result = PyList_New(0);

      for (std::vector<XBMCAddon::String >::iterator iter = apiResult.begin(); iter != apiResult.end(); ++iter)
      {
        PyObject* pyentry1;
        pyentry1 = PyUnicode_DecodeUTF8((*iter).c_str(),(*iter).size(),"surrogateescape");

        PyList_Append(result, pyentry1);
        Py_DECREF(pyentry1);
      }



    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagGame_getPublisher (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagGame*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagGame_Type,"getPublisher","XBMCAddon::xbmc::InfoTagGame"))-> getPublisher(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getPublisher\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getPublisher\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagGame_getDeveloper (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagGame*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagGame_Type,"getDeveloper","XBMCAddon::xbmc::InfoTagGame"))-> getDeveloper(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getDeveloper\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getDeveloper\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagGame_getOverview (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagGame*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagGame_Type,"getOverview","XBMCAddon::xbmc::InfoTagGame"))-> getOverview(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getOverview\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getOverview\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagGame_getYear (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    unsigned int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagGame*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagGame_Type,"getYear","XBMCAddon::xbmc::InfoTagGame"))-> getYear(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getYear\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getYear\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("I", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagGame_getGameClient (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagGame*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagGame_Type,"getGameClient","XBMCAddon::xbmc::InfoTagGame"))-> getGameClient(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getGameClient\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getGameClient\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagGame_setTitle (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "title",
          NULL};

    std::string  title ;
    PyObject* pytitle = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pytitle
       ))
    {
      return NULL;
    }


    try
    {
      if (pytitle) PyXBMCGetUnicodeString(title,pytitle,false,"title","setTitle"); 

      ((XBMCAddon::xbmc::InfoTagGame*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagGame_Type,"setTitle","XBMCAddon::xbmc::InfoTagGame"))-> setTitle(  title  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setTitle\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setTitle\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagGame_setPlatform (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "platform",
          NULL};

    std::string  platform ;
    PyObject* pyplatform = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyplatform
       ))
    {
      return NULL;
    }


    try
    {
      if (pyplatform) PyXBMCGetUnicodeString(platform,pyplatform,false,"platform","setPlatform"); 

      ((XBMCAddon::xbmc::InfoTagGame*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagGame_Type,"setPlatform","XBMCAddon::xbmc::InfoTagGame"))-> setPlatform(  platform  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setPlatform\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setPlatform\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagGame_setGenres (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "genres",
          NULL};

    std::vector< XBMCAddon::String  >  genres ;
    PyObject* pygenres = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pygenres
       ))
    {
      return NULL;
    }


    try
    {
      
    if (pygenres)
    {
      bool isTuple = PyObject_TypeCheck(pygenres,&PyTuple_Type);
      if (!isTuple && !PyObject_TypeCheck(pygenres,&PyList_Type))
        throw WrongTypeException("The parameter \"genres\" must be either a Tuple or a List.");

      
      PyObject *pyentry1 = NULL;
      Py_ssize_t vecSize = (isTuple ? PyTuple_Size(pygenres) : PyList_Size(pygenres));
      genres.reserve(vecSize);
      for(Py_ssize_t i = 0; i < vecSize; i++)
      {
        pyentry1 = (isTuple ? PyTuple_GetItem(pygenres, i) : PyList_GetItem(pygenres, i));
        std::string  entry1;
        if (pyentry1) PyXBMCGetUnicodeString(entry1,pyentry1,false,"entry1","setGenres");
        genres.push_back(std::move(entry1));
      }
    }
 

      ((XBMCAddon::xbmc::InfoTagGame*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagGame_Type,"setGenres","XBMCAddon::xbmc::InfoTagGame"))-> setGenres(  genres  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setGenres\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setGenres\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagGame_setPublisher (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "publisher",
          NULL};

    std::string  publisher ;
    PyObject* pypublisher = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pypublisher
       ))
    {
      return NULL;
    }


    try
    {
      if (pypublisher) PyXBMCGetUnicodeString(publisher,pypublisher,false,"publisher","setPublisher"); 

      ((XBMCAddon::xbmc::InfoTagGame*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagGame_Type,"setPublisher","XBMCAddon::xbmc::InfoTagGame"))-> setPublisher(  publisher  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setPublisher\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setPublisher\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagGame_setDeveloper (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "developer",
          NULL};

    std::string  developer ;
    PyObject* pydeveloper = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pydeveloper
       ))
    {
      return NULL;
    }


    try
    {
      if (pydeveloper) PyXBMCGetUnicodeString(developer,pydeveloper,false,"developer","setDeveloper"); 

      ((XBMCAddon::xbmc::InfoTagGame*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagGame_Type,"setDeveloper","XBMCAddon::xbmc::InfoTagGame"))-> setDeveloper(  developer  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setDeveloper\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setDeveloper\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagGame_setOverview (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "overview",
          NULL};

    std::string  overview ;
    PyObject* pyoverview = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyoverview
       ))
    {
      return NULL;
    }


    try
    {
      if (pyoverview) PyXBMCGetUnicodeString(overview,pyoverview,false,"overview","setOverview"); 

      ((XBMCAddon::xbmc::InfoTagGame*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagGame_Type,"setOverview","XBMCAddon::xbmc::InfoTagGame"))-> setOverview(  overview  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setOverview\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setOverview\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagGame_setYear (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "year",
          NULL};

    unsigned int  year ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "I",
       const_cast<char**>(keywords),
         &year
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagGame*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagGame_Type,"setYear","XBMCAddon::xbmc::InfoTagGame"))-> setYear(  year  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setYear\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setYear\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagGame_setGameClient (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "gameClient",
          NULL};

    std::string  gameClient ;
    PyObject* pygameClient = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pygameClient
       ))
    {
      return NULL;
    }


    try
    {
      if (pygameClient) PyXBMCGetUnicodeString(gameClient,pygameClient,false,"gameClient","setGameClient"); 

      ((XBMCAddon::xbmc::InfoTagGame*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagGame_Type,"setGameClient","XBMCAddon::xbmc::InfoTagGame"))-> setGameClient(  gameClient  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setGameClient\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setGameClient\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_New (PyTypeObject* pytype  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "offscreen",
          NULL};

    bool  offscreen  = false;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "|b",
       const_cast<char**>(keywords),
         &offscreen
       ))
    {
      return NULL;
    }

    XBMCAddon::xbmc::InfoTagMusic * apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = new XBMCAddon::xbmc::InfoTagMusic(  offscreen  );
      prepareForReturn(apiResult);
    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"new XBMCAddon::xbmc::InfoTagMusic\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"new XBMCAddon::xbmc::InfoTagMusic\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,pytype,false);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getDbId (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getDbId","XBMCAddon::xbmc::InfoTagMusic"))-> getDbId(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getDbId\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getDbId\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getURL (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getURL","XBMCAddon::xbmc::InfoTagMusic"))-> getURL(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getURL\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getURL\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getTitle (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getTitle","XBMCAddon::xbmc::InfoTagMusic"))-> getTitle(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getTitle\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getTitle\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getMediaType (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getMediaType","XBMCAddon::xbmc::InfoTagMusic"))-> getMediaType(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getMediaType\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getMediaType\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getArtist (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getArtist","XBMCAddon::xbmc::InfoTagMusic"))-> getArtist(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getArtist\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getArtist\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getAlbum (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getAlbum","XBMCAddon::xbmc::InfoTagMusic"))-> getAlbum(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getAlbum\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getAlbum\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getAlbumArtist (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getAlbumArtist","XBMCAddon::xbmc::InfoTagMusic"))-> getAlbumArtist(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getAlbumArtist\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getAlbumArtist\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getGenre (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getGenre","XBMCAddon::xbmc::InfoTagMusic"))-> getGenre(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getGenre\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getGenre\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getGenres (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    std::vector< XBMCAddon::String  >  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getGenres","XBMCAddon::xbmc::InfoTagMusic"))-> getGenres(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getGenres\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getGenres\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    
      result = PyList_New(0);

      for (std::vector<XBMCAddon::String >::iterator iter = apiResult.begin(); iter != apiResult.end(); ++iter)
      {
        PyObject* pyentry1;
        pyentry1 = PyUnicode_DecodeUTF8((*iter).c_str(),(*iter).size(),"surrogateescape");

        PyList_Append(result, pyentry1);
        Py_DECREF(pyentry1);
      }



    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getDuration (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getDuration","XBMCAddon::xbmc::InfoTagMusic"))-> getDuration(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getDuration\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getDuration\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getYear (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getYear","XBMCAddon::xbmc::InfoTagMusic"))-> getYear(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getYear\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getYear\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getRating (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getRating","XBMCAddon::xbmc::InfoTagMusic"))-> getRating(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getRating\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getRating\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getUserRating (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getUserRating","XBMCAddon::xbmc::InfoTagMusic"))-> getUserRating(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getUserRating\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getUserRating\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getTrack (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getTrack","XBMCAddon::xbmc::InfoTagMusic"))-> getTrack(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getTrack\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getTrack\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getDisc (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getDisc","XBMCAddon::xbmc::InfoTagMusic"))-> getDisc(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getDisc\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getDisc\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getReleaseDate (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getReleaseDate","XBMCAddon::xbmc::InfoTagMusic"))-> getReleaseDate(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getReleaseDate\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getReleaseDate\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getListeners (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getListeners","XBMCAddon::xbmc::InfoTagMusic"))-> getListeners(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getListeners\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getListeners\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getPlayCount (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getPlayCount","XBMCAddon::xbmc::InfoTagMusic"))-> getPlayCount(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getPlayCount\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getPlayCount\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getLastPlayed (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getLastPlayed","XBMCAddon::xbmc::InfoTagMusic"))-> getLastPlayed(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getLastPlayed\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getLastPlayed\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getLastPlayedAsW3C (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getLastPlayedAsW3C","XBMCAddon::xbmc::InfoTagMusic"))-> getLastPlayedAsW3C(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getLastPlayedAsW3C\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getLastPlayedAsW3C\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getComment (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getComment","XBMCAddon::xbmc::InfoTagMusic"))-> getComment(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getComment\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getComment\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getLyrics (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getLyrics","XBMCAddon::xbmc::InfoTagMusic"))-> getLyrics(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getLyrics\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getLyrics\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getMusicBrainzTrackID (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getMusicBrainzTrackID","XBMCAddon::xbmc::InfoTagMusic"))-> getMusicBrainzTrackID(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getMusicBrainzTrackID\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getMusicBrainzTrackID\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getMusicBrainzArtistID (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    std::vector< XBMCAddon::String  >  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getMusicBrainzArtistID","XBMCAddon::xbmc::InfoTagMusic"))-> getMusicBrainzArtistID(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getMusicBrainzArtistID\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getMusicBrainzArtistID\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    
      result = PyList_New(0);

      for (std::vector<XBMCAddon::String >::iterator iter = apiResult.begin(); iter != apiResult.end(); ++iter)
      {
        PyObject* pyentry1;
        pyentry1 = PyUnicode_DecodeUTF8((*iter).c_str(),(*iter).size(),"surrogateescape");

        PyList_Append(result, pyentry1);
        Py_DECREF(pyentry1);
      }



    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getMusicBrainzAlbumID (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getMusicBrainzAlbumID","XBMCAddon::xbmc::InfoTagMusic"))-> getMusicBrainzAlbumID(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getMusicBrainzAlbumID\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getMusicBrainzAlbumID\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getMusicBrainzReleaseGroupID (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getMusicBrainzReleaseGroupID","XBMCAddon::xbmc::InfoTagMusic"))-> getMusicBrainzReleaseGroupID(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getMusicBrainzReleaseGroupID\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getMusicBrainzReleaseGroupID\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_getMusicBrainzAlbumArtistID (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    std::vector< XBMCAddon::String  >  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"getMusicBrainzAlbumArtistID","XBMCAddon::xbmc::InfoTagMusic"))-> getMusicBrainzAlbumArtistID(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getMusicBrainzAlbumArtistID\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getMusicBrainzAlbumArtistID\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    
      result = PyList_New(0);

      for (std::vector<XBMCAddon::String >::iterator iter = apiResult.begin(); iter != apiResult.end(); ++iter)
      {
        PyObject* pyentry1;
        pyentry1 = PyUnicode_DecodeUTF8((*iter).c_str(),(*iter).size(),"surrogateescape");

        PyList_Append(result, pyentry1);
        Py_DECREF(pyentry1);
      }



    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setDbId (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "dbId",
          "type",
          NULL};

    int  dbId ;
    std::string  type ;
    PyObject* pytype = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "iO",
       const_cast<char**>(keywords),
         &dbId,
         &pytype
       ))
    {
      return NULL;
    }


    try
    {
      if (pytype) PyXBMCGetUnicodeString(type,pytype,false,"type","setDbId"); 

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setDbId","XBMCAddon::xbmc::InfoTagMusic"))-> setDbId(  dbId,  type  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setDbId\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setDbId\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setURL (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "url",
          NULL};

    std::string  url ;
    PyObject* pyurl = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyurl
       ))
    {
      return NULL;
    }


    try
    {
      if (pyurl) PyXBMCGetUnicodeString(url,pyurl,false,"url","setURL"); 

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setURL","XBMCAddon::xbmc::InfoTagMusic"))-> setURL(  url  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setURL\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setURL\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setMediaType (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "mediaType",
          NULL};

    std::string  mediaType ;
    PyObject* pymediaType = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pymediaType
       ))
    {
      return NULL;
    }


    try
    {
      if (pymediaType) PyXBMCGetUnicodeString(mediaType,pymediaType,false,"mediaType","setMediaType"); 

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setMediaType","XBMCAddon::xbmc::InfoTagMusic"))-> setMediaType(  mediaType  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setMediaType\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setMediaType\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setTrack (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "track",
          NULL};

    int  track ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &track
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setTrack","XBMCAddon::xbmc::InfoTagMusic"))-> setTrack(  track  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setTrack\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setTrack\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setDisc (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "disc",
          NULL};

    int  disc ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &disc
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setDisc","XBMCAddon::xbmc::InfoTagMusic"))-> setDisc(  disc  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setDisc\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setDisc\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setDuration (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "duration",
          NULL};

    int  duration ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &duration
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setDuration","XBMCAddon::xbmc::InfoTagMusic"))-> setDuration(  duration  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setDuration\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setDuration\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setYear (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "year",
          NULL};

    int  year ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &year
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setYear","XBMCAddon::xbmc::InfoTagMusic"))-> setYear(  year  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setYear\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setYear\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setReleaseDate (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "releaseDate",
          NULL};

    std::string  releaseDate ;
    PyObject* pyreleaseDate = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyreleaseDate
       ))
    {
      return NULL;
    }


    try
    {
      if (pyreleaseDate) PyXBMCGetUnicodeString(releaseDate,pyreleaseDate,false,"releaseDate","setReleaseDate"); 

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setReleaseDate","XBMCAddon::xbmc::InfoTagMusic"))-> setReleaseDate(  releaseDate  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setReleaseDate\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setReleaseDate\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setListeners (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "listeners",
          NULL};

    int  listeners ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &listeners
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setListeners","XBMCAddon::xbmc::InfoTagMusic"))-> setListeners(  listeners  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setListeners\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setListeners\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setPlayCount (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "playcount",
          NULL};

    int  playcount ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &playcount
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setPlayCount","XBMCAddon::xbmc::InfoTagMusic"))-> setPlayCount(  playcount  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setPlayCount\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setPlayCount\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setGenres (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "genres",
          NULL};

    std::vector< XBMCAddon::String  >  genres ;
    PyObject* pygenres = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pygenres
       ))
    {
      return NULL;
    }


    try
    {
      
    if (pygenres)
    {
      bool isTuple = PyObject_TypeCheck(pygenres,&PyTuple_Type);
      if (!isTuple && !PyObject_TypeCheck(pygenres,&PyList_Type))
        throw WrongTypeException("The parameter \"genres\" must be either a Tuple or a List.");

      
      PyObject *pyentry1 = NULL;
      Py_ssize_t vecSize = (isTuple ? PyTuple_Size(pygenres) : PyList_Size(pygenres));
      genres.reserve(vecSize);
      for(Py_ssize_t i = 0; i < vecSize; i++)
      {
        pyentry1 = (isTuple ? PyTuple_GetItem(pygenres, i) : PyList_GetItem(pygenres, i));
        std::string  entry1;
        if (pyentry1) PyXBMCGetUnicodeString(entry1,pyentry1,false,"entry1","setGenres");
        genres.push_back(std::move(entry1));
      }
    }
 

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setGenres","XBMCAddon::xbmc::InfoTagMusic"))-> setGenres(  genres  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setGenres\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setGenres\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setAlbum (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "album",
          NULL};

    std::string  album ;
    PyObject* pyalbum = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyalbum
       ))
    {
      return NULL;
    }


    try
    {
      if (pyalbum) PyXBMCGetUnicodeString(album,pyalbum,false,"album","setAlbum"); 

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setAlbum","XBMCAddon::xbmc::InfoTagMusic"))-> setAlbum(  album  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setAlbum\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setAlbum\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setArtist (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "artist",
          NULL};

    std::string  artist ;
    PyObject* pyartist = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyartist
       ))
    {
      return NULL;
    }


    try
    {
      if (pyartist) PyXBMCGetUnicodeString(artist,pyartist,false,"artist","setArtist"); 

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setArtist","XBMCAddon::xbmc::InfoTagMusic"))-> setArtist(  artist  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setArtist\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setArtist\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setAlbumArtist (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "albumArtist",
          NULL};

    std::string  albumArtist ;
    PyObject* pyalbumArtist = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyalbumArtist
       ))
    {
      return NULL;
    }


    try
    {
      if (pyalbumArtist) PyXBMCGetUnicodeString(albumArtist,pyalbumArtist,false,"albumArtist","setAlbumArtist"); 

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setAlbumArtist","XBMCAddon::xbmc::InfoTagMusic"))-> setAlbumArtist(  albumArtist  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setAlbumArtist\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setAlbumArtist\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setTitle (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "title",
          NULL};

    std::string  title ;
    PyObject* pytitle = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pytitle
       ))
    {
      return NULL;
    }


    try
    {
      if (pytitle) PyXBMCGetUnicodeString(title,pytitle,false,"title","setTitle"); 

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setTitle","XBMCAddon::xbmc::InfoTagMusic"))-> setTitle(  title  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setTitle\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setTitle\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setRating (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "rating",
          NULL};

    float  rating ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "f",
       const_cast<char**>(keywords),
         &rating
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setRating","XBMCAddon::xbmc::InfoTagMusic"))-> setRating(  rating  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setRating\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setRating\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setUserRating (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "userrating",
          NULL};

    int  userrating ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &userrating
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setUserRating","XBMCAddon::xbmc::InfoTagMusic"))-> setUserRating(  userrating  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setUserRating\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setUserRating\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setLyrics (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "lyrics",
          NULL};

    std::string  lyrics ;
    PyObject* pylyrics = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pylyrics
       ))
    {
      return NULL;
    }


    try
    {
      if (pylyrics) PyXBMCGetUnicodeString(lyrics,pylyrics,false,"lyrics","setLyrics"); 

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setLyrics","XBMCAddon::xbmc::InfoTagMusic"))-> setLyrics(  lyrics  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setLyrics\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setLyrics\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setLastPlayed (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "lastPlayed",
          NULL};

    std::string  lastPlayed ;
    PyObject* pylastPlayed = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pylastPlayed
       ))
    {
      return NULL;
    }


    try
    {
      if (pylastPlayed) PyXBMCGetUnicodeString(lastPlayed,pylastPlayed,false,"lastPlayed","setLastPlayed"); 

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setLastPlayed","XBMCAddon::xbmc::InfoTagMusic"))-> setLastPlayed(  lastPlayed  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setLastPlayed\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setLastPlayed\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setMusicBrainzTrackID (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "musicBrainzTrackID",
          NULL};

    std::string  musicBrainzTrackID ;
    PyObject* pymusicBrainzTrackID = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pymusicBrainzTrackID
       ))
    {
      return NULL;
    }


    try
    {
      if (pymusicBrainzTrackID) PyXBMCGetUnicodeString(musicBrainzTrackID,pymusicBrainzTrackID,false,"musicBrainzTrackID","setMusicBrainzTrackID"); 

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setMusicBrainzTrackID","XBMCAddon::xbmc::InfoTagMusic"))-> setMusicBrainzTrackID(  musicBrainzTrackID  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setMusicBrainzTrackID\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setMusicBrainzTrackID\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setMusicBrainzArtistID (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "musicBrainzArtistID",
          NULL};

    std::vector< XBMCAddon::String  >  musicBrainzArtistID ;
    PyObject* pymusicBrainzArtistID = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pymusicBrainzArtistID
       ))
    {
      return NULL;
    }


    try
    {
      
    if (pymusicBrainzArtistID)
    {
      bool isTuple = PyObject_TypeCheck(pymusicBrainzArtistID,&PyTuple_Type);
      if (!isTuple && !PyObject_TypeCheck(pymusicBrainzArtistID,&PyList_Type))
        throw WrongTypeException("The parameter \"musicBrainzArtistID\" must be either a Tuple or a List.");

      
      PyObject *pyentry1 = NULL;
      Py_ssize_t vecSize = (isTuple ? PyTuple_Size(pymusicBrainzArtistID) : PyList_Size(pymusicBrainzArtistID));
      musicBrainzArtistID.reserve(vecSize);
      for(Py_ssize_t i = 0; i < vecSize; i++)
      {
        pyentry1 = (isTuple ? PyTuple_GetItem(pymusicBrainzArtistID, i) : PyList_GetItem(pymusicBrainzArtistID, i));
        std::string  entry1;
        if (pyentry1) PyXBMCGetUnicodeString(entry1,pyentry1,false,"entry1","setMusicBrainzArtistID");
        musicBrainzArtistID.push_back(std::move(entry1));
      }
    }
 

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setMusicBrainzArtistID","XBMCAddon::xbmc::InfoTagMusic"))-> setMusicBrainzArtistID(  musicBrainzArtistID  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setMusicBrainzArtistID\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setMusicBrainzArtistID\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setMusicBrainzAlbumID (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "musicBrainzAlbumID",
          NULL};

    std::string  musicBrainzAlbumID ;
    PyObject* pymusicBrainzAlbumID = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pymusicBrainzAlbumID
       ))
    {
      return NULL;
    }


    try
    {
      if (pymusicBrainzAlbumID) PyXBMCGetUnicodeString(musicBrainzAlbumID,pymusicBrainzAlbumID,false,"musicBrainzAlbumID","setMusicBrainzAlbumID"); 

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setMusicBrainzAlbumID","XBMCAddon::xbmc::InfoTagMusic"))-> setMusicBrainzAlbumID(  musicBrainzAlbumID  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setMusicBrainzAlbumID\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setMusicBrainzAlbumID\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setMusicBrainzReleaseGroupID (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "musicBrainzReleaseGroupID",
          NULL};

    std::string  musicBrainzReleaseGroupID ;
    PyObject* pymusicBrainzReleaseGroupID = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pymusicBrainzReleaseGroupID
       ))
    {
      return NULL;
    }


    try
    {
      if (pymusicBrainzReleaseGroupID) PyXBMCGetUnicodeString(musicBrainzReleaseGroupID,pymusicBrainzReleaseGroupID,false,"musicBrainzReleaseGroupID","setMusicBrainzReleaseGroupID"); 

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setMusicBrainzReleaseGroupID","XBMCAddon::xbmc::InfoTagMusic"))-> setMusicBrainzReleaseGroupID(  musicBrainzReleaseGroupID  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setMusicBrainzReleaseGroupID\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setMusicBrainzReleaseGroupID\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setMusicBrainzAlbumArtistID (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "musicBrainzAlbumArtistID",
          NULL};

    std::vector< XBMCAddon::String  >  musicBrainzAlbumArtistID ;
    PyObject* pymusicBrainzAlbumArtistID = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pymusicBrainzAlbumArtistID
       ))
    {
      return NULL;
    }


    try
    {
      
    if (pymusicBrainzAlbumArtistID)
    {
      bool isTuple = PyObject_TypeCheck(pymusicBrainzAlbumArtistID,&PyTuple_Type);
      if (!isTuple && !PyObject_TypeCheck(pymusicBrainzAlbumArtistID,&PyList_Type))
        throw WrongTypeException("The parameter \"musicBrainzAlbumArtistID\" must be either a Tuple or a List.");

      
      PyObject *pyentry1 = NULL;
      Py_ssize_t vecSize = (isTuple ? PyTuple_Size(pymusicBrainzAlbumArtistID) : PyList_Size(pymusicBrainzAlbumArtistID));
      musicBrainzAlbumArtistID.reserve(vecSize);
      for(Py_ssize_t i = 0; i < vecSize; i++)
      {
        pyentry1 = (isTuple ? PyTuple_GetItem(pymusicBrainzAlbumArtistID, i) : PyList_GetItem(pymusicBrainzAlbumArtistID, i));
        std::string  entry1;
        if (pyentry1) PyXBMCGetUnicodeString(entry1,pyentry1,false,"entry1","setMusicBrainzAlbumArtistID");
        musicBrainzAlbumArtistID.push_back(std::move(entry1));
      }
    }
 

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setMusicBrainzAlbumArtistID","XBMCAddon::xbmc::InfoTagMusic"))-> setMusicBrainzAlbumArtistID(  musicBrainzAlbumArtistID  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setMusicBrainzAlbumArtistID\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setMusicBrainzAlbumArtistID\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagMusic_setComment (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "comment",
          NULL};

    std::string  comment ;
    PyObject* pycomment = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pycomment
       ))
    {
      return NULL;
    }


    try
    {
      if (pycomment) PyXBMCGetUnicodeString(comment,pycomment,false,"comment","setComment"); 

      ((XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"setComment","XBMCAddon::xbmc::InfoTagMusic"))-> setComment(  comment  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setComment\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setComment\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagPicture_New (PyTypeObject* pytype  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "offscreen",
          NULL};

    bool  offscreen  = false;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "|b",
       const_cast<char**>(keywords),
         &offscreen
       ))
    {
      return NULL;
    }

    XBMCAddon::xbmc::InfoTagPicture * apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = new XBMCAddon::xbmc::InfoTagPicture(  offscreen  );
      prepareForReturn(apiResult);
    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"new XBMCAddon::xbmc::InfoTagPicture\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"new XBMCAddon::xbmc::InfoTagPicture\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,pytype,false);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagPicture_getResolution (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagPicture*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagPicture_Type,"getResolution","XBMCAddon::xbmc::InfoTagPicture"))-> getResolution(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getResolution\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getResolution\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagPicture_getDateTimeTaken (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagPicture*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagPicture_Type,"getDateTimeTaken","XBMCAddon::xbmc::InfoTagPicture"))-> getDateTimeTaken(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getDateTimeTaken\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getDateTimeTaken\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagPicture_setResolution (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "width",
          "height",
          NULL};

    int  width ;
    int  height ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "ii",
       const_cast<char**>(keywords),
         &width,
         &height
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagPicture*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagPicture_Type,"setResolution","XBMCAddon::xbmc::InfoTagPicture"))-> setResolution(  width,  height  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setResolution\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setResolution\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagPicture_setDateTimeTaken (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "datetimetaken",
          NULL};

    std::string  datetimetaken ;
    PyObject* pydatetimetaken = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pydatetimetaken
       ))
    {
      return NULL;
    }


    try
    {
      if (pydatetimetaken) PyXBMCGetUnicodeString(datetimetaken,pydatetimetaken,false,"datetimetaken","setDateTimeTaken"); 

      ((XBMCAddon::xbmc::InfoTagPicture*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagPicture_Type,"setDateTimeTaken","XBMCAddon::xbmc::InfoTagPicture"))-> setDateTimeTaken(  datetimetaken  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setDateTimeTaken\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setDateTimeTaken\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_New (PyTypeObject* pytype  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::xbmc::InfoTagRadioRDS * apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = new XBMCAddon::xbmc::InfoTagRadioRDS(  );
      prepareForReturn(apiResult);
    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"new XBMCAddon::xbmc::InfoTagRadioRDS\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"new XBMCAddon::xbmc::InfoTagRadioRDS\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,pytype,false);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getTitle (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getTitle","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getTitle(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getTitle\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getTitle\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getBand (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getBand","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getBand(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getBand\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getBand\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getArtist (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getArtist","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getArtist(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getArtist\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getArtist\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getComposer (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getComposer","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getComposer(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getComposer\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getComposer\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getConductor (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getConductor","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getConductor(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getConductor\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getConductor\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getAlbum (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getAlbum","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getAlbum(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getAlbum\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getAlbum\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getComment (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getComment","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getComment(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getComment\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getComment\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getAlbumTrackNumber (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getAlbumTrackNumber","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getAlbumTrackNumber(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getAlbumTrackNumber\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getAlbumTrackNumber\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getInfoNews (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getInfoNews","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getInfoNews(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getInfoNews\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getInfoNews\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getInfoNewsLocal (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getInfoNewsLocal","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getInfoNewsLocal(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getInfoNewsLocal\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getInfoNewsLocal\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getInfoSport (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getInfoSport","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getInfoSport(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getInfoSport\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getInfoSport\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getInfoStock (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getInfoStock","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getInfoStock(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getInfoStock\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getInfoStock\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getInfoWeather (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getInfoWeather","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getInfoWeather(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getInfoWeather\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getInfoWeather\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getInfoHoroscope (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getInfoHoroscope","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getInfoHoroscope(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getInfoHoroscope\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getInfoHoroscope\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getInfoCinema (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getInfoCinema","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getInfoCinema(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getInfoCinema\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getInfoCinema\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getInfoLottery (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getInfoLottery","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getInfoLottery(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getInfoLottery\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getInfoLottery\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getInfoOther (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getInfoOther","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getInfoOther(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getInfoOther\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getInfoOther\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getEditorialStaff (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getEditorialStaff","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getEditorialStaff(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getEditorialStaff\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getEditorialStaff\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getProgStation (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getProgStation","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getProgStation(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getProgStation\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getProgStation\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getProgStyle (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getProgStyle","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getProgStyle(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getProgStyle\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getProgStyle\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getProgHost (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getProgHost","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getProgHost(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getProgHost\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getProgHost\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getProgWebsite (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getProgWebsite","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getProgWebsite(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getProgWebsite\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getProgWebsite\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getProgNow (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getProgNow","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getProgNow(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getProgNow\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getProgNow\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getProgNext (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getProgNext","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getProgNext(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getProgNext\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getProgNext\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getPhoneHotline (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getPhoneHotline","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getPhoneHotline(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getPhoneHotline\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getPhoneHotline\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getEMailHotline (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getEMailHotline","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getEMailHotline(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getEMailHotline\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getEMailHotline\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getPhoneStudio (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getPhoneStudio","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getPhoneStudio(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getPhoneStudio\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getPhoneStudio\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getEMailStudio (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getEMailStudio","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getEMailStudio(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getEMailStudio\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getEMailStudio\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getSMSStudio (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"getSMSStudio","XBMCAddon::xbmc::InfoTagRadioRDS"))-> getSMSStudio(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getSMSStudio\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getSMSStudio\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Actor_New (PyTypeObject* pytype  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "name",
          "role",
          "order",
          "thumbnail",
          NULL};

    std::string  name  = XBMCAddon::emptyString;
    PyObject* pyname = NULL;
    std::string  role  = XBMCAddon::emptyString;
    PyObject* pyrole = NULL;
    int  order  = -1;
    std::string  thumbnail  = XBMCAddon::emptyString;
    PyObject* pythumbnail = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "|OOiO",
       const_cast<char**>(keywords),
         &pyname,
         &pyrole,
         &order,
         &pythumbnail
       ))
    {
      return NULL;
    }

    XBMCAddon::xbmc::Actor * apiResult;
    try
    {
      if (pyname) PyXBMCGetUnicodeString(name,pyname,false,"name","Actor"); 
      if (pyrole) PyXBMCGetUnicodeString(role,pyrole,false,"role","Actor"); 
      if (pythumbnail) PyXBMCGetUnicodeString(thumbnail,pythumbnail,false,"thumbnail","Actor"); 

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = new XBMCAddon::xbmc::Actor(  name,  role,  order,  thumbnail  );
      prepareForReturn(apiResult);
    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"new XBMCAddon::xbmc::Actor\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"new XBMCAddon::xbmc::Actor\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,pytype,false);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Actor_getName (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Actor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Actor_Type,"getName","XBMCAddon::xbmc::Actor"))-> getName(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getName\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getName\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Actor_getRole (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Actor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Actor_Type,"getRole","XBMCAddon::xbmc::Actor"))-> getRole(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getRole\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getRole\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Actor_getOrder (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Actor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Actor_Type,"getOrder","XBMCAddon::xbmc::Actor"))-> getOrder(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getOrder\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getOrder\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Actor_getThumbnail (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Actor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Actor_Type,"getThumbnail","XBMCAddon::xbmc::Actor"))-> getThumbnail(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getThumbnail\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getThumbnail\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Actor_setName (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "name",
          NULL};

    std::string  name ;
    PyObject* pyname = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyname
       ))
    {
      return NULL;
    }


    try
    {
      if (pyname) PyXBMCGetUnicodeString(name,pyname,false,"name","setName"); 

      ((XBMCAddon::xbmc::Actor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Actor_Type,"setName","XBMCAddon::xbmc::Actor"))-> setName(  name  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setName\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setName\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Actor_setRole (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "role",
          NULL};

    std::string  role ;
    PyObject* pyrole = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyrole
       ))
    {
      return NULL;
    }


    try
    {
      if (pyrole) PyXBMCGetUnicodeString(role,pyrole,false,"role","setRole"); 

      ((XBMCAddon::xbmc::Actor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Actor_Type,"setRole","XBMCAddon::xbmc::Actor"))-> setRole(  role  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setRole\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setRole\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Actor_setOrder (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "order",
          NULL};

    int  order ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &order
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::Actor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Actor_Type,"setOrder","XBMCAddon::xbmc::Actor"))-> setOrder(  order  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setOrder\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setOrder\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Actor_setThumbnail (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "thumbnail",
          NULL};

    std::string  thumbnail ;
    PyObject* pythumbnail = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pythumbnail
       ))
    {
      return NULL;
    }


    try
    {
      if (pythumbnail) PyXBMCGetUnicodeString(thumbnail,pythumbnail,false,"thumbnail","setThumbnail"); 

      ((XBMCAddon::xbmc::Actor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Actor_Type,"setThumbnail","XBMCAddon::xbmc::Actor"))-> setThumbnail(  thumbnail  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setThumbnail\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setThumbnail\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_VideoStreamDetail_New (PyTypeObject* pytype  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "width",
          "height",
          "aspect",
          "duration",
          "codec",
          "stereomode",
          "language",
          "hdrtype",
          NULL};

    int  width  = 0;
    int  height  = 0;
    float  aspect  = 0.0;
    int  duration  = 0;
    std::string  codec  = XBMCAddon::emptyString;
    PyObject* pycodec = NULL;
    std::string  stereomode  = XBMCAddon::emptyString;
    PyObject* pystereomode = NULL;
    std::string  language  = XBMCAddon::emptyString;
    PyObject* pylanguage = NULL;
    std::string  hdrtype  = XBMCAddon::emptyString;
    PyObject* pyhdrtype = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "|iifiOOOO",
       const_cast<char**>(keywords),
         &width,
         &height,
         &aspect,
         &duration,
         &pycodec,
         &pystereomode,
         &pylanguage,
         &pyhdrtype
       ))
    {
      return NULL;
    }

    XBMCAddon::xbmc::VideoStreamDetail * apiResult;
    try
    {
      if (pycodec) PyXBMCGetUnicodeString(codec,pycodec,false,"codec","VideoStreamDetail"); 
      if (pystereomode) PyXBMCGetUnicodeString(stereomode,pystereomode,false,"stereomode","VideoStreamDetail"); 
      if (pylanguage) PyXBMCGetUnicodeString(language,pylanguage,false,"language","VideoStreamDetail"); 
      if (pyhdrtype) PyXBMCGetUnicodeString(hdrtype,pyhdrtype,false,"hdrtype","VideoStreamDetail"); 

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = new XBMCAddon::xbmc::VideoStreamDetail(  width,  height,  aspect,  duration,  codec,  stereomode,  language,  hdrtype  );
      prepareForReturn(apiResult);
    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"new XBMCAddon::xbmc::VideoStreamDetail\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"new XBMCAddon::xbmc::VideoStreamDetail\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,pytype,false);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_VideoStreamDetail_getWidth (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::VideoStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_VideoStreamDetail_Type,"getWidth","XBMCAddon::xbmc::VideoStreamDetail"))-> getWidth(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getWidth\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getWidth\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_VideoStreamDetail_getHeight (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::VideoStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_VideoStreamDetail_Type,"getHeight","XBMCAddon::xbmc::VideoStreamDetail"))-> getHeight(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getHeight\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getHeight\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_VideoStreamDetail_getAspect (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    float  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::VideoStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_VideoStreamDetail_Type,"getAspect","XBMCAddon::xbmc::VideoStreamDetail"))-> getAspect(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getAspect\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getAspect\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("f", static_cast<double>(apiResult));

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_VideoStreamDetail_getDuration (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::VideoStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_VideoStreamDetail_Type,"getDuration","XBMCAddon::xbmc::VideoStreamDetail"))-> getDuration(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getDuration\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getDuration\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_VideoStreamDetail_getCodec (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::VideoStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_VideoStreamDetail_Type,"getCodec","XBMCAddon::xbmc::VideoStreamDetail"))-> getCodec(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getCodec\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getCodec\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_VideoStreamDetail_getStereoMode (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::VideoStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_VideoStreamDetail_Type,"getStereoMode","XBMCAddon::xbmc::VideoStreamDetail"))-> getStereoMode(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getStereoMode\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getStereoMode\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_VideoStreamDetail_getLanguage (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::VideoStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_VideoStreamDetail_Type,"getLanguage","XBMCAddon::xbmc::VideoStreamDetail"))-> getLanguage(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getLanguage\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getLanguage\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_VideoStreamDetail_getHDRType (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::VideoStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_VideoStreamDetail_Type,"getHDRType","XBMCAddon::xbmc::VideoStreamDetail"))-> getHDRType(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getHDRType\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getHDRType\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_VideoStreamDetail_setWidth (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "width",
          NULL};

    int  width ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &width
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::VideoStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_VideoStreamDetail_Type,"setWidth","XBMCAddon::xbmc::VideoStreamDetail"))-> setWidth(  width  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setWidth\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setWidth\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_VideoStreamDetail_setHeight (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "height",
          NULL};

    int  height ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &height
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::VideoStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_VideoStreamDetail_Type,"setHeight","XBMCAddon::xbmc::VideoStreamDetail"))-> setHeight(  height  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setHeight\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setHeight\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_VideoStreamDetail_setAspect (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "aspect",
          NULL};

    float  aspect ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "f",
       const_cast<char**>(keywords),
         &aspect
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::VideoStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_VideoStreamDetail_Type,"setAspect","XBMCAddon::xbmc::VideoStreamDetail"))-> setAspect(  aspect  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setAspect\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setAspect\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_VideoStreamDetail_setDuration (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "duration",
          NULL};

    int  duration ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &duration
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::VideoStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_VideoStreamDetail_Type,"setDuration","XBMCAddon::xbmc::VideoStreamDetail"))-> setDuration(  duration  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setDuration\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setDuration\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_VideoStreamDetail_setCodec (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "codec",
          NULL};

    std::string  codec ;
    PyObject* pycodec = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pycodec
       ))
    {
      return NULL;
    }


    try
    {
      if (pycodec) PyXBMCGetUnicodeString(codec,pycodec,false,"codec","setCodec"); 

      ((XBMCAddon::xbmc::VideoStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_VideoStreamDetail_Type,"setCodec","XBMCAddon::xbmc::VideoStreamDetail"))-> setCodec(  codec  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setCodec\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setCodec\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_VideoStreamDetail_setStereoMode (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "stereomode",
          NULL};

    std::string  stereomode ;
    PyObject* pystereomode = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pystereomode
       ))
    {
      return NULL;
    }


    try
    {
      if (pystereomode) PyXBMCGetUnicodeString(stereomode,pystereomode,false,"stereomode","setStereoMode"); 

      ((XBMCAddon::xbmc::VideoStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_VideoStreamDetail_Type,"setStereoMode","XBMCAddon::xbmc::VideoStreamDetail"))-> setStereoMode(  stereomode  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setStereoMode\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setStereoMode\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_VideoStreamDetail_setLanguage (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "language",
          NULL};

    std::string  language ;
    PyObject* pylanguage = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pylanguage
       ))
    {
      return NULL;
    }


    try
    {
      if (pylanguage) PyXBMCGetUnicodeString(language,pylanguage,false,"language","setLanguage"); 

      ((XBMCAddon::xbmc::VideoStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_VideoStreamDetail_Type,"setLanguage","XBMCAddon::xbmc::VideoStreamDetail"))-> setLanguage(  language  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setLanguage\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setLanguage\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_VideoStreamDetail_setHDRType (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "hdrtype",
          NULL};

    std::string  hdrtype ;
    PyObject* pyhdrtype = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyhdrtype
       ))
    {
      return NULL;
    }


    try
    {
      if (pyhdrtype) PyXBMCGetUnicodeString(hdrtype,pyhdrtype,false,"hdrtype","setHDRType"); 

      ((XBMCAddon::xbmc::VideoStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_VideoStreamDetail_Type,"setHDRType","XBMCAddon::xbmc::VideoStreamDetail"))-> setHDRType(  hdrtype  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setHDRType\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setHDRType\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_AudioStreamDetail_New (PyTypeObject* pytype  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "channels",
          "codec",
          "language",
          NULL};

    int  channels  = -1;
    std::string  codec  = XBMCAddon::emptyString;
    PyObject* pycodec = NULL;
    std::string  language  = XBMCAddon::emptyString;
    PyObject* pylanguage = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "|iOO",
       const_cast<char**>(keywords),
         &channels,
         &pycodec,
         &pylanguage
       ))
    {
      return NULL;
    }

    XBMCAddon::xbmc::AudioStreamDetail * apiResult;
    try
    {
      if (pycodec) PyXBMCGetUnicodeString(codec,pycodec,false,"codec","AudioStreamDetail"); 
      if (pylanguage) PyXBMCGetUnicodeString(language,pylanguage,false,"language","AudioStreamDetail"); 

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = new XBMCAddon::xbmc::AudioStreamDetail(  channels,  codec,  language  );
      prepareForReturn(apiResult);
    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"new XBMCAddon::xbmc::AudioStreamDetail\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"new XBMCAddon::xbmc::AudioStreamDetail\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,pytype,false);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_AudioStreamDetail_getChannels (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::AudioStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_AudioStreamDetail_Type,"getChannels","XBMCAddon::xbmc::AudioStreamDetail"))-> getChannels(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getChannels\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getChannels\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_AudioStreamDetail_getCodec (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::AudioStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_AudioStreamDetail_Type,"getCodec","XBMCAddon::xbmc::AudioStreamDetail"))-> getCodec(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getCodec\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getCodec\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_AudioStreamDetail_getLanguage (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::AudioStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_AudioStreamDetail_Type,"getLanguage","XBMCAddon::xbmc::AudioStreamDetail"))-> getLanguage(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getLanguage\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getLanguage\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_AudioStreamDetail_setChannels (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "channels",
          NULL};

    int  channels ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &channels
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::AudioStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_AudioStreamDetail_Type,"setChannels","XBMCAddon::xbmc::AudioStreamDetail"))-> setChannels(  channels  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setChannels\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setChannels\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_AudioStreamDetail_setCodec (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "codec",
          NULL};

    std::string  codec ;
    PyObject* pycodec = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pycodec
       ))
    {
      return NULL;
    }


    try
    {
      if (pycodec) PyXBMCGetUnicodeString(codec,pycodec,false,"codec","setCodec"); 

      ((XBMCAddon::xbmc::AudioStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_AudioStreamDetail_Type,"setCodec","XBMCAddon::xbmc::AudioStreamDetail"))-> setCodec(  codec  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setCodec\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setCodec\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_AudioStreamDetail_setLanguage (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "language",
          NULL};

    std::string  language ;
    PyObject* pylanguage = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pylanguage
       ))
    {
      return NULL;
    }


    try
    {
      if (pylanguage) PyXBMCGetUnicodeString(language,pylanguage,false,"language","setLanguage"); 

      ((XBMCAddon::xbmc::AudioStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_AudioStreamDetail_Type,"setLanguage","XBMCAddon::xbmc::AudioStreamDetail"))-> setLanguage(  language  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setLanguage\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setLanguage\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_SubtitleStreamDetail_New (PyTypeObject* pytype  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "language",
          NULL};

    std::string  language  = XBMCAddon::emptyString;
    PyObject* pylanguage = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "|O",
       const_cast<char**>(keywords),
         &pylanguage
       ))
    {
      return NULL;
    }

    XBMCAddon::xbmc::SubtitleStreamDetail * apiResult;
    try
    {
      if (pylanguage) PyXBMCGetUnicodeString(language,pylanguage,false,"language","SubtitleStreamDetail"); 

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = new XBMCAddon::xbmc::SubtitleStreamDetail(  language  );
      prepareForReturn(apiResult);
    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"new XBMCAddon::xbmc::SubtitleStreamDetail\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"new XBMCAddon::xbmc::SubtitleStreamDetail\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,pytype,false);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_SubtitleStreamDetail_getLanguage (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::SubtitleStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_SubtitleStreamDetail_Type,"getLanguage","XBMCAddon::xbmc::SubtitleStreamDetail"))-> getLanguage(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getLanguage\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getLanguage\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_SubtitleStreamDetail_setLanguage (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "language",
          NULL};

    std::string  language ;
    PyObject* pylanguage = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pylanguage
       ))
    {
      return NULL;
    }


    try
    {
      if (pylanguage) PyXBMCGetUnicodeString(language,pylanguage,false,"language","setLanguage"); 

      ((XBMCAddon::xbmc::SubtitleStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_SubtitleStreamDetail_Type,"setLanguage","XBMCAddon::xbmc::SubtitleStreamDetail"))-> setLanguage(  language  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setLanguage\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setLanguage\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_New (PyTypeObject* pytype  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "offscreen",
          NULL};

    bool  offscreen  = false;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "|b",
       const_cast<char**>(keywords),
         &offscreen
       ))
    {
      return NULL;
    }

    XBMCAddon::xbmc::InfoTagVideo * apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = new XBMCAddon::xbmc::InfoTagVideo(  offscreen  );
      prepareForReturn(apiResult);
    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"new XBMCAddon::xbmc::InfoTagVideo\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"new XBMCAddon::xbmc::InfoTagVideo\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,pytype,false);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getDbId (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getDbId","XBMCAddon::xbmc::InfoTagVideo"))-> getDbId(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getDbId\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getDbId\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getDirector (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getDirector","XBMCAddon::xbmc::InfoTagVideo"))-> getDirector(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getDirector\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getDirector\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getDirectors (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    std::vector< XBMCAddon::String  >  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getDirectors","XBMCAddon::xbmc::InfoTagVideo"))-> getDirectors(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getDirectors\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getDirectors\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    
      result = PyList_New(0);

      for (std::vector<XBMCAddon::String >::iterator iter = apiResult.begin(); iter != apiResult.end(); ++iter)
      {
        PyObject* pyentry1;
        pyentry1 = PyUnicode_DecodeUTF8((*iter).c_str(),(*iter).size(),"surrogateescape");

        PyList_Append(result, pyentry1);
        Py_DECREF(pyentry1);
      }



    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getWritingCredits (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getWritingCredits","XBMCAddon::xbmc::InfoTagVideo"))-> getWritingCredits(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getWritingCredits\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getWritingCredits\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getWriters (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    std::vector< XBMCAddon::String  >  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getWriters","XBMCAddon::xbmc::InfoTagVideo"))-> getWriters(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getWriters\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getWriters\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    
      result = PyList_New(0);

      for (std::vector<XBMCAddon::String >::iterator iter = apiResult.begin(); iter != apiResult.end(); ++iter)
      {
        PyObject* pyentry1;
        pyentry1 = PyUnicode_DecodeUTF8((*iter).c_str(),(*iter).size(),"surrogateescape");

        PyList_Append(result, pyentry1);
        Py_DECREF(pyentry1);
      }



    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getGenre (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getGenre","XBMCAddon::xbmc::InfoTagVideo"))-> getGenre(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getGenre\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getGenre\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getGenres (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    std::vector< XBMCAddon::String  >  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getGenres","XBMCAddon::xbmc::InfoTagVideo"))-> getGenres(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getGenres\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getGenres\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    
      result = PyList_New(0);

      for (std::vector<XBMCAddon::String >::iterator iter = apiResult.begin(); iter != apiResult.end(); ++iter)
      {
        PyObject* pyentry1;
        pyentry1 = PyUnicode_DecodeUTF8((*iter).c_str(),(*iter).size(),"surrogateescape");

        PyList_Append(result, pyentry1);
        Py_DECREF(pyentry1);
      }



    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getTagLine (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getTagLine","XBMCAddon::xbmc::InfoTagVideo"))-> getTagLine(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getTagLine\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getTagLine\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getPlotOutline (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getPlotOutline","XBMCAddon::xbmc::InfoTagVideo"))-> getPlotOutline(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getPlotOutline\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getPlotOutline\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getPlot (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getPlot","XBMCAddon::xbmc::InfoTagVideo"))-> getPlot(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getPlot\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getPlot\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getPictureURL (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getPictureURL","XBMCAddon::xbmc::InfoTagVideo"))-> getPictureURL(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getPictureURL\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getPictureURL\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getTitle (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getTitle","XBMCAddon::xbmc::InfoTagVideo"))-> getTitle(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getTitle\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getTitle\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getTVShowTitle (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getTVShowTitle","XBMCAddon::xbmc::InfoTagVideo"))-> getTVShowTitle(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getTVShowTitle\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getTVShowTitle\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getMediaType (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getMediaType","XBMCAddon::xbmc::InfoTagVideo"))-> getMediaType(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getMediaType\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getMediaType\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getVotes (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getVotes","XBMCAddon::xbmc::InfoTagVideo"))-> getVotes(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getVotes\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getVotes\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getVotesAsInt (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "type",
          NULL};

    std::string  type  = "";
    PyObject* pytype = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "|O",
       const_cast<char**>(keywords),
         &pytype
       ))
    {
      return NULL;
    }

    int  apiResult;
    try
    {
      if (pytype) PyXBMCGetUnicodeString(type,pytype,false,"type","getVotesAsInt"); 

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getVotesAsInt","XBMCAddon::xbmc::InfoTagVideo"))-> getVotesAsInt(  type  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getVotesAsInt\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getVotesAsInt\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getCast (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getCast","XBMCAddon::xbmc::InfoTagVideo"))-> getCast(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getCast\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getCast\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getActors (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    std::vector< XBMCAddon::xbmc::Actor * >  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getActors","XBMCAddon::xbmc::InfoTagVideo"))-> getActors(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getActors\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getActors\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    
      result = PyList_New(0);

      for (std::vector<XBMCAddon::xbmc::Actor *>::iterator iter = apiResult.begin(); iter != apiResult.end(); ++iter)
      {
        PyObject* pyentry1;
        pyentry1 = makePythonInstance((*iter),true);
        PyList_Append(result, pyentry1);
        Py_DECREF(pyentry1);
      }



    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getFile (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getFile","XBMCAddon::xbmc::InfoTagVideo"))-> getFile(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getFile\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getFile\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getPath (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getPath","XBMCAddon::xbmc::InfoTagVideo"))-> getPath(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getPath\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getPath\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getFilenameAndPath (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getFilenameAndPath","XBMCAddon::xbmc::InfoTagVideo"))-> getFilenameAndPath(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getFilenameAndPath\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getFilenameAndPath\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getIMDBNumber (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getIMDBNumber","XBMCAddon::xbmc::InfoTagVideo"))-> getIMDBNumber(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getIMDBNumber\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getIMDBNumber\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getSeason (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getSeason","XBMCAddon::xbmc::InfoTagVideo"))-> getSeason(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getSeason\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getSeason\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getEpisode (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getEpisode","XBMCAddon::xbmc::InfoTagVideo"))-> getEpisode(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getEpisode\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getEpisode\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getYear (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getYear","XBMCAddon::xbmc::InfoTagVideo"))-> getYear(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getYear\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getYear\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getRating (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "type",
          NULL};

    std::string  type  = "";
    PyObject* pytype = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "|O",
       const_cast<char**>(keywords),
         &pytype
       ))
    {
      return NULL;
    }

    double  apiResult;
    try
    {
      if (pytype) PyXBMCGetUnicodeString(type,pytype,false,"type","getRating"); 

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getRating","XBMCAddon::xbmc::InfoTagVideo"))-> getRating(  type  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getRating\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getRating\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyFloat_FromDouble(apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getUserRating (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getUserRating","XBMCAddon::xbmc::InfoTagVideo"))-> getUserRating(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getUserRating\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getUserRating\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getPlayCount (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getPlayCount","XBMCAddon::xbmc::InfoTagVideo"))-> getPlayCount(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getPlayCount\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getPlayCount\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getLastPlayed (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getLastPlayed","XBMCAddon::xbmc::InfoTagVideo"))-> getLastPlayed(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getLastPlayed\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getLastPlayed\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getLastPlayedAsW3C (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getLastPlayedAsW3C","XBMCAddon::xbmc::InfoTagVideo"))-> getLastPlayedAsW3C(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getLastPlayedAsW3C\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getLastPlayedAsW3C\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getOriginalTitle (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getOriginalTitle","XBMCAddon::xbmc::InfoTagVideo"))-> getOriginalTitle(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getOriginalTitle\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getOriginalTitle\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getPremiered (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getPremiered","XBMCAddon::xbmc::InfoTagVideo"))-> getPremiered(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getPremiered\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getPremiered\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getPremieredAsW3C (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getPremieredAsW3C","XBMCAddon::xbmc::InfoTagVideo"))-> getPremieredAsW3C(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getPremieredAsW3C\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getPremieredAsW3C\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getFirstAired (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getFirstAired","XBMCAddon::xbmc::InfoTagVideo"))-> getFirstAired(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getFirstAired\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getFirstAired\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getFirstAiredAsW3C (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getFirstAiredAsW3C","XBMCAddon::xbmc::InfoTagVideo"))-> getFirstAiredAsW3C(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getFirstAiredAsW3C\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getFirstAiredAsW3C\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getTrailer (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getTrailer","XBMCAddon::xbmc::InfoTagVideo"))-> getTrailer(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getTrailer\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getTrailer\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getArtist (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    std::vector< std::string  >  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getArtist","XBMCAddon::xbmc::InfoTagVideo"))-> getArtist(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getArtist\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getArtist\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    
      result = PyList_New(0);

      for (std::vector<std::string >::iterator iter = apiResult.begin(); iter != apiResult.end(); ++iter)
      {
        PyObject* pyentry1;
        pyentry1 = PyUnicode_DecodeUTF8((*iter).c_str(),(*iter).size(),"surrogateescape");

        PyList_Append(result, pyentry1);
        Py_DECREF(pyentry1);
      }



    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getAlbum (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getAlbum","XBMCAddon::xbmc::InfoTagVideo"))-> getAlbum(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getAlbum\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getAlbum\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getTrack (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getTrack","XBMCAddon::xbmc::InfoTagVideo"))-> getTrack(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getTrack\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getTrack\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getDuration (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    unsigned int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getDuration","XBMCAddon::xbmc::InfoTagVideo"))-> getDuration(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getDuration\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getDuration\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("I", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getResumeTime (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    double  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getResumeTime","XBMCAddon::xbmc::InfoTagVideo"))-> getResumeTime(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getResumeTime\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getResumeTime\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyFloat_FromDouble(apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getResumeTimeTotal (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    double  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getResumeTimeTotal","XBMCAddon::xbmc::InfoTagVideo"))-> getResumeTimeTotal(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getResumeTimeTotal\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getResumeTimeTotal\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyFloat_FromDouble(apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_getUniqueID (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "key",
          NULL};

    char * key  = nullptr;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "s",
       const_cast<char**>(keywords),
         &key
       ))
    {
      return NULL;
    }

    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"getUniqueID","XBMCAddon::xbmc::InfoTagVideo"))-> getUniqueID(  key  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getUniqueID\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getUniqueID\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setUniqueID (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "uniqueid",
          "type",
          "isdefault",
          NULL};

    std::string  uniqueid ;
    PyObject* pyuniqueid = NULL;
    std::string  type  = "";
    PyObject* pytype = NULL;
    bool  isdefault  = false;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O|Ob",
       const_cast<char**>(keywords),
         &pyuniqueid,
         &pytype,
         &isdefault
       ))
    {
      return NULL;
    }


    try
    {
      if (pyuniqueid) PyXBMCGetUnicodeString(uniqueid,pyuniqueid,false,"uniqueid","setUniqueID"); 
      if (pytype) PyXBMCGetUnicodeString(type,pytype,false,"type","setUniqueID"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setUniqueID","XBMCAddon::xbmc::InfoTagVideo"))-> setUniqueID(  uniqueid,  type,  isdefault  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setUniqueID\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setUniqueID\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setUniqueIDs (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "uniqueIDs",
          "defaultuniqueid",
          NULL};

    std::map< XBMCAddon::String ,XBMCAddon::String  >  uniqueIDs ;
    PyObject* pyuniqueIDs = NULL;
    std::string  defaultuniqueid  = "";
    PyObject* pydefaultuniqueid = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O|O",
       const_cast<char**>(keywords),
         &pyuniqueIDs,
         &pydefaultuniqueid
       ))
    {
      return NULL;
    }


    try
    {
      
    {
      PyObject *pykey, *pyvalue;
      Py_ssize_t pos = 0;
      while(PyDict_Next(pyuniqueIDs, &pos, &pykey, &pyvalue))
      {
        std::string  key;
        std::string  value;
        if (pykey) PyXBMCGetUnicodeString(key,pykey,false,"key","setUniqueIDs");
        if (pyvalue) PyXBMCGetUnicodeString(value,pyvalue,false,"value","setUniqueIDs");
        uniqueIDs.emplace(std::move(key), std::move(value));
      }
    } 
      if (pydefaultuniqueid) PyXBMCGetUnicodeString(defaultuniqueid,pydefaultuniqueid,false,"defaultuniqueid","setUniqueIDs"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setUniqueIDs","XBMCAddon::xbmc::InfoTagVideo"))-> setUniqueIDs(  uniqueIDs,  defaultuniqueid  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setUniqueIDs\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setUniqueIDs\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setDbId (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "dbid",
          NULL};

    int  dbid ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &dbid
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setDbId","XBMCAddon::xbmc::InfoTagVideo"))-> setDbId(  dbid  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setDbId\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setDbId\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setYear (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "year",
          NULL};

    int  year ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &year
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setYear","XBMCAddon::xbmc::InfoTagVideo"))-> setYear(  year  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setYear\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setYear\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setEpisode (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "episode",
          NULL};

    int  episode ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &episode
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setEpisode","XBMCAddon::xbmc::InfoTagVideo"))-> setEpisode(  episode  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setEpisode\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setEpisode\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setSeason (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "season",
          NULL};

    int  season ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &season
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setSeason","XBMCAddon::xbmc::InfoTagVideo"))-> setSeason(  season  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setSeason\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setSeason\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setSortEpisode (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "sortepisode",
          NULL};

    int  sortepisode ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &sortepisode
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setSortEpisode","XBMCAddon::xbmc::InfoTagVideo"))-> setSortEpisode(  sortepisode  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setSortEpisode\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setSortEpisode\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setSortSeason (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "sortseason",
          NULL};

    int  sortseason ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &sortseason
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setSortSeason","XBMCAddon::xbmc::InfoTagVideo"))-> setSortSeason(  sortseason  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setSortSeason\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setSortSeason\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setEpisodeGuide (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "episodeguide",
          NULL};

    std::string  episodeguide ;
    PyObject* pyepisodeguide = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyepisodeguide
       ))
    {
      return NULL;
    }


    try
    {
      if (pyepisodeguide) PyXBMCGetUnicodeString(episodeguide,pyepisodeguide,false,"episodeguide","setEpisodeGuide"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setEpisodeGuide","XBMCAddon::xbmc::InfoTagVideo"))-> setEpisodeGuide(  episodeguide  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setEpisodeGuide\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setEpisodeGuide\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setTop250 (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "top250",
          NULL};

    int  top250 ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &top250
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setTop250","XBMCAddon::xbmc::InfoTagVideo"))-> setTop250(  top250  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setTop250\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setTop250\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setSetId (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "setid",
          NULL};

    int  setid ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &setid
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setSetId","XBMCAddon::xbmc::InfoTagVideo"))-> setSetId(  setid  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setSetId\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setSetId\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setTrackNumber (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "tracknumber",
          NULL};

    int  tracknumber ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &tracknumber
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setTrackNumber","XBMCAddon::xbmc::InfoTagVideo"))-> setTrackNumber(  tracknumber  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setTrackNumber\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setTrackNumber\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setRating (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "rating",
          "votes",
          "type",
          "isdefault",
          NULL};

    float  rating ;
    int  votes  = 0;
    std::string  type  = "";
    PyObject* pytype = NULL;
    bool  isdefault  = false;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "f|iOb",
       const_cast<char**>(keywords),
         &rating,
         &votes,
         &pytype,
         &isdefault
       ))
    {
      return NULL;
    }


    try
    {
      if (pytype) PyXBMCGetUnicodeString(type,pytype,false,"type","setRating"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setRating","XBMCAddon::xbmc::InfoTagVideo"))-> setRating(  rating,  votes,  type,  isdefault  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setRating\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setRating\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setRatings (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "ratings",
          "defaultrating",
          NULL};

    std::map< XBMCAddon::String ,Tuple< float ,int  >  >  ratings ;
    PyObject* pyratings = NULL;
    std::string  defaultrating  = "";
    PyObject* pydefaultrating = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O|O",
       const_cast<char**>(keywords),
         &pyratings,
         &pydefaultrating
       ))
    {
      return NULL;
    }


    try
    {
      
    {
      PyObject *pykey, *pyvalue;
      Py_ssize_t pos = 0;
      while(PyDict_Next(pyratings, &pos, &pykey, &pyvalue))
      {
        std::string  key;
        Tuple< float ,int  >  value;
        if (pykey) PyXBMCGetUnicodeString(key,pykey,false,"key","setRatings");
        
    if(pyvalue)
    {
      bool isTuple = PyObject_TypeCheck(pyvalue,&PyTuple_Type);
      if (!isTuple && !PyObject_TypeCheck(pyvalue,&PyList_Type))
        throw WrongTypeException("The parameter \"value\" must be either a Tuple or a List.");
      Py_ssize_t vecSize = (isTuple ? PyTuple_Size(pyvalue) : PyList_Size(pyvalue));

      if (vecSize > 0)
      {
        PyObject *pyentry0_1 = NULL;
        pyentry0_1 = (isTuple ? PyTuple_GetItem(pyvalue, 0) : PyList_GetItem(pyvalue, 0));
        float  entry0_1;
        entry0_1 = (float)PyFloat_AsDouble(pyentry0_1);
        value.first() = entry0_1;
      }

      if (vecSize > 1)
      {
        PyObject *pyentry1_1 = NULL;
        pyentry1_1 = (isTuple ? PyTuple_GetItem(pyvalue, 1) : PyList_GetItem(pyvalue, 1));
        int  entry1_1;
        entry1_1 = (int)PyLong_AsLong(pyentry1_1);
        value.second() = entry1_1;
      }

    }

        ratings.emplace(std::move(key), std::move(value));
      }
    } 
      if (pydefaultrating) PyXBMCGetUnicodeString(defaultrating,pydefaultrating,false,"defaultrating","setRatings"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setRatings","XBMCAddon::xbmc::InfoTagVideo"))-> setRatings(  ratings,  defaultrating  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setRatings\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setRatings\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setUserRating (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "userrating",
          NULL};

    int  userrating ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &userrating
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setUserRating","XBMCAddon::xbmc::InfoTagVideo"))-> setUserRating(  userrating  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setUserRating\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setUserRating\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setPlaycount (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "playcount",
          NULL};

    int  playcount ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &playcount
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setPlaycount","XBMCAddon::xbmc::InfoTagVideo"))-> setPlaycount(  playcount  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setPlaycount\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setPlaycount\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setMpaa (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "mpaa",
          NULL};

    std::string  mpaa ;
    PyObject* pympaa = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pympaa
       ))
    {
      return NULL;
    }


    try
    {
      if (pympaa) PyXBMCGetUnicodeString(mpaa,pympaa,false,"mpaa","setMpaa"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setMpaa","XBMCAddon::xbmc::InfoTagVideo"))-> setMpaa(  mpaa  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setMpaa\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setMpaa\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setPlot (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "plot",
          NULL};

    std::string  plot ;
    PyObject* pyplot = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyplot
       ))
    {
      return NULL;
    }


    try
    {
      if (pyplot) PyXBMCGetUnicodeString(plot,pyplot,false,"plot","setPlot"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setPlot","XBMCAddon::xbmc::InfoTagVideo"))-> setPlot(  plot  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setPlot\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setPlot\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setPlotOutline (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "plotoutline",
          NULL};

    std::string  plotoutline ;
    PyObject* pyplotoutline = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyplotoutline
       ))
    {
      return NULL;
    }


    try
    {
      if (pyplotoutline) PyXBMCGetUnicodeString(plotoutline,pyplotoutline,false,"plotoutline","setPlotOutline"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setPlotOutline","XBMCAddon::xbmc::InfoTagVideo"))-> setPlotOutline(  plotoutline  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setPlotOutline\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setPlotOutline\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setTitle (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "title",
          NULL};

    std::string  title ;
    PyObject* pytitle = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pytitle
       ))
    {
      return NULL;
    }


    try
    {
      if (pytitle) PyXBMCGetUnicodeString(title,pytitle,false,"title","setTitle"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setTitle","XBMCAddon::xbmc::InfoTagVideo"))-> setTitle(  title  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setTitle\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setTitle\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setOriginalTitle (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "originaltitle",
          NULL};

    std::string  originaltitle ;
    PyObject* pyoriginaltitle = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyoriginaltitle
       ))
    {
      return NULL;
    }


    try
    {
      if (pyoriginaltitle) PyXBMCGetUnicodeString(originaltitle,pyoriginaltitle,false,"originaltitle","setOriginalTitle"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setOriginalTitle","XBMCAddon::xbmc::InfoTagVideo"))-> setOriginalTitle(  originaltitle  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setOriginalTitle\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setOriginalTitle\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setSortTitle (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "sorttitle",
          NULL};

    std::string  sorttitle ;
    PyObject* pysorttitle = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pysorttitle
       ))
    {
      return NULL;
    }


    try
    {
      if (pysorttitle) PyXBMCGetUnicodeString(sorttitle,pysorttitle,false,"sorttitle","setSortTitle"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setSortTitle","XBMCAddon::xbmc::InfoTagVideo"))-> setSortTitle(  sorttitle  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setSortTitle\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setSortTitle\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setTagLine (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "tagline",
          NULL};

    std::string  tagline ;
    PyObject* pytagline = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pytagline
       ))
    {
      return NULL;
    }


    try
    {
      if (pytagline) PyXBMCGetUnicodeString(tagline,pytagline,false,"tagline","setTagLine"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setTagLine","XBMCAddon::xbmc::InfoTagVideo"))-> setTagLine(  tagline  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setTagLine\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setTagLine\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setTvShowTitle (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "tvshowtitle",
          NULL};

    std::string  tvshowtitle ;
    PyObject* pytvshowtitle = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pytvshowtitle
       ))
    {
      return NULL;
    }


    try
    {
      if (pytvshowtitle) PyXBMCGetUnicodeString(tvshowtitle,pytvshowtitle,false,"tvshowtitle","setTvShowTitle"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setTvShowTitle","XBMCAddon::xbmc::InfoTagVideo"))-> setTvShowTitle(  tvshowtitle  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setTvShowTitle\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setTvShowTitle\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setTvShowStatus (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "status",
          NULL};

    std::string  status ;
    PyObject* pystatus = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pystatus
       ))
    {
      return NULL;
    }


    try
    {
      if (pystatus) PyXBMCGetUnicodeString(status,pystatus,false,"status","setTvShowStatus"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setTvShowStatus","XBMCAddon::xbmc::InfoTagVideo"))-> setTvShowStatus(  status  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setTvShowStatus\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setTvShowStatus\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setGenres (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "genre",
          NULL};

    std::vector< XBMCAddon::String  >  genre ;
    PyObject* pygenre = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pygenre
       ))
    {
      return NULL;
    }


    try
    {
      
    if (pygenre)
    {
      bool isTuple = PyObject_TypeCheck(pygenre,&PyTuple_Type);
      if (!isTuple && !PyObject_TypeCheck(pygenre,&PyList_Type))
        throw WrongTypeException("The parameter \"genre\" must be either a Tuple or a List.");

      
      PyObject *pyentry1 = NULL;
      Py_ssize_t vecSize = (isTuple ? PyTuple_Size(pygenre) : PyList_Size(pygenre));
      genre.reserve(vecSize);
      for(Py_ssize_t i = 0; i < vecSize; i++)
      {
        pyentry1 = (isTuple ? PyTuple_GetItem(pygenre, i) : PyList_GetItem(pygenre, i));
        std::string  entry1;
        if (pyentry1) PyXBMCGetUnicodeString(entry1,pyentry1,false,"entry1","setGenres");
        genre.push_back(std::move(entry1));
      }
    }
 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setGenres","XBMCAddon::xbmc::InfoTagVideo"))-> setGenres(  genre  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setGenres\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setGenres\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setCountries (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "countries",
          NULL};

    std::vector< XBMCAddon::String  >  countries ;
    PyObject* pycountries = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pycountries
       ))
    {
      return NULL;
    }


    try
    {
      
    if (pycountries)
    {
      bool isTuple = PyObject_TypeCheck(pycountries,&PyTuple_Type);
      if (!isTuple && !PyObject_TypeCheck(pycountries,&PyList_Type))
        throw WrongTypeException("The parameter \"countries\" must be either a Tuple or a List.");

      
      PyObject *pyentry1 = NULL;
      Py_ssize_t vecSize = (isTuple ? PyTuple_Size(pycountries) : PyList_Size(pycountries));
      countries.reserve(vecSize);
      for(Py_ssize_t i = 0; i < vecSize; i++)
      {
        pyentry1 = (isTuple ? PyTuple_GetItem(pycountries, i) : PyList_GetItem(pycountries, i));
        std::string  entry1;
        if (pyentry1) PyXBMCGetUnicodeString(entry1,pyentry1,false,"entry1","setCountries");
        countries.push_back(std::move(entry1));
      }
    }
 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setCountries","XBMCAddon::xbmc::InfoTagVideo"))-> setCountries(  countries  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setCountries\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setCountries\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setDirectors (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "directors",
          NULL};

    std::vector< XBMCAddon::String  >  directors ;
    PyObject* pydirectors = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pydirectors
       ))
    {
      return NULL;
    }


    try
    {
      
    if (pydirectors)
    {
      bool isTuple = PyObject_TypeCheck(pydirectors,&PyTuple_Type);
      if (!isTuple && !PyObject_TypeCheck(pydirectors,&PyList_Type))
        throw WrongTypeException("The parameter \"directors\" must be either a Tuple or a List.");

      
      PyObject *pyentry1 = NULL;
      Py_ssize_t vecSize = (isTuple ? PyTuple_Size(pydirectors) : PyList_Size(pydirectors));
      directors.reserve(vecSize);
      for(Py_ssize_t i = 0; i < vecSize; i++)
      {
        pyentry1 = (isTuple ? PyTuple_GetItem(pydirectors, i) : PyList_GetItem(pydirectors, i));
        std::string  entry1;
        if (pyentry1) PyXBMCGetUnicodeString(entry1,pyentry1,false,"entry1","setDirectors");
        directors.push_back(std::move(entry1));
      }
    }
 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setDirectors","XBMCAddon::xbmc::InfoTagVideo"))-> setDirectors(  directors  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setDirectors\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setDirectors\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setStudios (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "studios",
          NULL};

    std::vector< XBMCAddon::String  >  studios ;
    PyObject* pystudios = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pystudios
       ))
    {
      return NULL;
    }


    try
    {
      
    if (pystudios)
    {
      bool isTuple = PyObject_TypeCheck(pystudios,&PyTuple_Type);
      if (!isTuple && !PyObject_TypeCheck(pystudios,&PyList_Type))
        throw WrongTypeException("The parameter \"studios\" must be either a Tuple or a List.");

      
      PyObject *pyentry1 = NULL;
      Py_ssize_t vecSize = (isTuple ? PyTuple_Size(pystudios) : PyList_Size(pystudios));
      studios.reserve(vecSize);
      for(Py_ssize_t i = 0; i < vecSize; i++)
      {
        pyentry1 = (isTuple ? PyTuple_GetItem(pystudios, i) : PyList_GetItem(pystudios, i));
        std::string  entry1;
        if (pyentry1) PyXBMCGetUnicodeString(entry1,pyentry1,false,"entry1","setStudios");
        studios.push_back(std::move(entry1));
      }
    }
 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setStudios","XBMCAddon::xbmc::InfoTagVideo"))-> setStudios(  studios  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setStudios\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setStudios\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setWriters (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "writers",
          NULL};

    std::vector< XBMCAddon::String  >  writers ;
    PyObject* pywriters = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pywriters
       ))
    {
      return NULL;
    }


    try
    {
      
    if (pywriters)
    {
      bool isTuple = PyObject_TypeCheck(pywriters,&PyTuple_Type);
      if (!isTuple && !PyObject_TypeCheck(pywriters,&PyList_Type))
        throw WrongTypeException("The parameter \"writers\" must be either a Tuple or a List.");

      
      PyObject *pyentry1 = NULL;
      Py_ssize_t vecSize = (isTuple ? PyTuple_Size(pywriters) : PyList_Size(pywriters));
      writers.reserve(vecSize);
      for(Py_ssize_t i = 0; i < vecSize; i++)
      {
        pyentry1 = (isTuple ? PyTuple_GetItem(pywriters, i) : PyList_GetItem(pywriters, i));
        std::string  entry1;
        if (pyentry1) PyXBMCGetUnicodeString(entry1,pyentry1,false,"entry1","setWriters");
        writers.push_back(std::move(entry1));
      }
    }
 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setWriters","XBMCAddon::xbmc::InfoTagVideo"))-> setWriters(  writers  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setWriters\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setWriters\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setDuration (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "duration",
          NULL};

    int  duration ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &duration
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setDuration","XBMCAddon::xbmc::InfoTagVideo"))-> setDuration(  duration  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setDuration\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setDuration\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setPremiered (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "premiered",
          NULL};

    std::string  premiered ;
    PyObject* pypremiered = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pypremiered
       ))
    {
      return NULL;
    }


    try
    {
      if (pypremiered) PyXBMCGetUnicodeString(premiered,pypremiered,false,"premiered","setPremiered"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setPremiered","XBMCAddon::xbmc::InfoTagVideo"))-> setPremiered(  premiered  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setPremiered\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setPremiered\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setSet (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "set",
          NULL};

    std::string  set ;
    PyObject* pyset = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyset
       ))
    {
      return NULL;
    }


    try
    {
      if (pyset) PyXBMCGetUnicodeString(set,pyset,false,"set","setSet"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setSet","XBMCAddon::xbmc::InfoTagVideo"))-> setSet(  set  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setSet\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setSet\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setSetOverview (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "setoverview",
          NULL};

    std::string  setoverview ;
    PyObject* pysetoverview = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pysetoverview
       ))
    {
      return NULL;
    }


    try
    {
      if (pysetoverview) PyXBMCGetUnicodeString(setoverview,pysetoverview,false,"setoverview","setSetOverview"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setSetOverview","XBMCAddon::xbmc::InfoTagVideo"))-> setSetOverview(  setoverview  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setSetOverview\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setSetOverview\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setTags (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "tags",
          NULL};

    std::vector< XBMCAddon::String  >  tags ;
    PyObject* pytags = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pytags
       ))
    {
      return NULL;
    }


    try
    {
      
    if (pytags)
    {
      bool isTuple = PyObject_TypeCheck(pytags,&PyTuple_Type);
      if (!isTuple && !PyObject_TypeCheck(pytags,&PyList_Type))
        throw WrongTypeException("The parameter \"tags\" must be either a Tuple or a List.");

      
      PyObject *pyentry1 = NULL;
      Py_ssize_t vecSize = (isTuple ? PyTuple_Size(pytags) : PyList_Size(pytags));
      tags.reserve(vecSize);
      for(Py_ssize_t i = 0; i < vecSize; i++)
      {
        pyentry1 = (isTuple ? PyTuple_GetItem(pytags, i) : PyList_GetItem(pytags, i));
        std::string  entry1;
        if (pyentry1) PyXBMCGetUnicodeString(entry1,pyentry1,false,"entry1","setTags");
        tags.push_back(std::move(entry1));
      }
    }
 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setTags","XBMCAddon::xbmc::InfoTagVideo"))-> setTags(  tags  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setTags\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setTags\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setProductionCode (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "productioncode",
          NULL};

    std::string  productioncode ;
    PyObject* pyproductioncode = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyproductioncode
       ))
    {
      return NULL;
    }


    try
    {
      if (pyproductioncode) PyXBMCGetUnicodeString(productioncode,pyproductioncode,false,"productioncode","setProductionCode"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setProductionCode","XBMCAddon::xbmc::InfoTagVideo"))-> setProductionCode(  productioncode  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setProductionCode\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setProductionCode\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setFirstAired (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "firstaired",
          NULL};

    std::string  firstaired ;
    PyObject* pyfirstaired = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyfirstaired
       ))
    {
      return NULL;
    }


    try
    {
      if (pyfirstaired) PyXBMCGetUnicodeString(firstaired,pyfirstaired,false,"firstaired","setFirstAired"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setFirstAired","XBMCAddon::xbmc::InfoTagVideo"))-> setFirstAired(  firstaired  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setFirstAired\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setFirstAired\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setLastPlayed (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "lastplayed",
          NULL};

    std::string  lastplayed ;
    PyObject* pylastplayed = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pylastplayed
       ))
    {
      return NULL;
    }


    try
    {
      if (pylastplayed) PyXBMCGetUnicodeString(lastplayed,pylastplayed,false,"lastplayed","setLastPlayed"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setLastPlayed","XBMCAddon::xbmc::InfoTagVideo"))-> setLastPlayed(  lastplayed  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setLastPlayed\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setLastPlayed\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setAlbum (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "album",
          NULL};

    std::string  album ;
    PyObject* pyalbum = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyalbum
       ))
    {
      return NULL;
    }


    try
    {
      if (pyalbum) PyXBMCGetUnicodeString(album,pyalbum,false,"album","setAlbum"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setAlbum","XBMCAddon::xbmc::InfoTagVideo"))-> setAlbum(  album  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setAlbum\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setAlbum\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setVotes (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "votes",
          NULL};

    int  votes ;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i",
       const_cast<char**>(keywords),
         &votes
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setVotes","XBMCAddon::xbmc::InfoTagVideo"))-> setVotes(  votes  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setVotes\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setVotes\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setTrailer (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "trailer",
          NULL};

    std::string  trailer ;
    PyObject* pytrailer = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pytrailer
       ))
    {
      return NULL;
    }


    try
    {
      if (pytrailer) PyXBMCGetUnicodeString(trailer,pytrailer,false,"trailer","setTrailer"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setTrailer","XBMCAddon::xbmc::InfoTagVideo"))-> setTrailer(  trailer  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setTrailer\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setTrailer\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setPath (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "path",
          NULL};

    std::string  path ;
    PyObject* pypath = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pypath
       ))
    {
      return NULL;
    }


    try
    {
      if (pypath) PyXBMCGetUnicodeString(path,pypath,false,"path","setPath"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setPath","XBMCAddon::xbmc::InfoTagVideo"))-> setPath(  path  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setPath\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setPath\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setFilenameAndPath (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "filenameandpath",
          NULL};

    std::string  filenameandpath ;
    PyObject* pyfilenameandpath = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyfilenameandpath
       ))
    {
      return NULL;
    }


    try
    {
      if (pyfilenameandpath) PyXBMCGetUnicodeString(filenameandpath,pyfilenameandpath,false,"filenameandpath","setFilenameAndPath"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setFilenameAndPath","XBMCAddon::xbmc::InfoTagVideo"))-> setFilenameAndPath(  filenameandpath  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setFilenameAndPath\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setFilenameAndPath\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setIMDBNumber (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "imdbnumber",
          NULL};

    std::string  imdbnumber ;
    PyObject* pyimdbnumber = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyimdbnumber
       ))
    {
      return NULL;
    }


    try
    {
      if (pyimdbnumber) PyXBMCGetUnicodeString(imdbnumber,pyimdbnumber,false,"imdbnumber","setIMDBNumber"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setIMDBNumber","XBMCAddon::xbmc::InfoTagVideo"))-> setIMDBNumber(  imdbnumber  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setIMDBNumber\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setIMDBNumber\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setDateAdded (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "dateadded",
          NULL};

    std::string  dateadded ;
    PyObject* pydateadded = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pydateadded
       ))
    {
      return NULL;
    }


    try
    {
      if (pydateadded) PyXBMCGetUnicodeString(dateadded,pydateadded,false,"dateadded","setDateAdded"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setDateAdded","XBMCAddon::xbmc::InfoTagVideo"))-> setDateAdded(  dateadded  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setDateAdded\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setDateAdded\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setMediaType (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "mediatype",
          NULL};

    std::string  mediatype ;
    PyObject* pymediatype = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pymediatype
       ))
    {
      return NULL;
    }


    try
    {
      if (pymediatype) PyXBMCGetUnicodeString(mediatype,pymediatype,false,"mediatype","setMediaType"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setMediaType","XBMCAddon::xbmc::InfoTagVideo"))-> setMediaType(  mediatype  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setMediaType\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setMediaType\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setShowLinks (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "showlinks",
          NULL};

    std::vector< XBMCAddon::String  >  showlinks ;
    PyObject* pyshowlinks = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyshowlinks
       ))
    {
      return NULL;
    }


    try
    {
      
    if (pyshowlinks)
    {
      bool isTuple = PyObject_TypeCheck(pyshowlinks,&PyTuple_Type);
      if (!isTuple && !PyObject_TypeCheck(pyshowlinks,&PyList_Type))
        throw WrongTypeException("The parameter \"showlinks\" must be either a Tuple or a List.");

      
      PyObject *pyentry1 = NULL;
      Py_ssize_t vecSize = (isTuple ? PyTuple_Size(pyshowlinks) : PyList_Size(pyshowlinks));
      showlinks.reserve(vecSize);
      for(Py_ssize_t i = 0; i < vecSize; i++)
      {
        pyentry1 = (isTuple ? PyTuple_GetItem(pyshowlinks, i) : PyList_GetItem(pyshowlinks, i));
        std::string  entry1;
        if (pyentry1) PyXBMCGetUnicodeString(entry1,pyentry1,false,"entry1","setShowLinks");
        showlinks.push_back(std::move(entry1));
      }
    }
 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setShowLinks","XBMCAddon::xbmc::InfoTagVideo"))-> setShowLinks(  showlinks  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setShowLinks\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setShowLinks\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setArtists (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "artists",
          NULL};

    std::vector< XBMCAddon::String  >  artists ;
    PyObject* pyartists = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyartists
       ))
    {
      return NULL;
    }


    try
    {
      
    if (pyartists)
    {
      bool isTuple = PyObject_TypeCheck(pyartists,&PyTuple_Type);
      if (!isTuple && !PyObject_TypeCheck(pyartists,&PyList_Type))
        throw WrongTypeException("The parameter \"artists\" must be either a Tuple or a List.");

      
      PyObject *pyentry1 = NULL;
      Py_ssize_t vecSize = (isTuple ? PyTuple_Size(pyartists) : PyList_Size(pyartists));
      artists.reserve(vecSize);
      for(Py_ssize_t i = 0; i < vecSize; i++)
      {
        pyentry1 = (isTuple ? PyTuple_GetItem(pyartists, i) : PyList_GetItem(pyartists, i));
        std::string  entry1;
        if (pyentry1) PyXBMCGetUnicodeString(entry1,pyentry1,false,"entry1","setArtists");
        artists.push_back(std::move(entry1));
      }
    }
 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setArtists","XBMCAddon::xbmc::InfoTagVideo"))-> setArtists(  artists  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setArtists\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setArtists\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setCast (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "actors",
          NULL};

    std::vector< XBMCAddon::xbmc::Actor const * >  actors ;
    PyObject* pyactors = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyactors
       ))
    {
      return NULL;
    }


    try
    {
      
    if (pyactors)
    {
      bool isTuple = PyObject_TypeCheck(pyactors,&PyTuple_Type);
      if (!isTuple && !PyObject_TypeCheck(pyactors,&PyList_Type))
        throw WrongTypeException("The parameter \"actors\" must be either a Tuple or a List.");

      
      PyObject *pyentry1 = NULL;
      Py_ssize_t vecSize = (isTuple ? PyTuple_Size(pyactors) : PyList_Size(pyactors));
      actors.reserve(vecSize);
      for(Py_ssize_t i = 0; i < vecSize; i++)
      {
        pyentry1 = (isTuple ? PyTuple_GetItem(pyactors, i) : PyList_GetItem(pyactors, i));
        XBMCAddon::xbmc::Actor * entry1;
        entry1 = (XBMCAddon::xbmc::Actor *)retrieveApiInstance(pyentry1,"p.XBMCAddon::xbmc::Actor","XBMCAddon::xbmc::","setCast");
        actors.push_back(entry1);
      }
    }
 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setCast","XBMCAddon::xbmc::InfoTagVideo"))-> setCast(  actors  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setCast\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setCast\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_setResumePoint (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "time",
          "totaltime",
          NULL};

    double  time ;
    double  totaltime  = 0.0;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "d|d",
       const_cast<char**>(keywords),
         &time,
         &totaltime
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"setResumePoint","XBMCAddon::xbmc::InfoTagVideo"))-> setResumePoint(  time,  totaltime  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setResumePoint\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setResumePoint\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_addSeason (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "number",
          "name",
          NULL};

    int  number ;
    std::string  name  = "";
    PyObject* pyname = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "i|O",
       const_cast<char**>(keywords),
         &number,
         &pyname
       ))
    {
      return NULL;
    }


    try
    {
      if (pyname) PyXBMCGetUnicodeString(name,pyname,false,"name","addSeason"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"addSeason","XBMCAddon::xbmc::InfoTagVideo"))-> addSeason(  number,  name  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"addSeason\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"addSeason\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_addSeasons (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "namedseasons",
          NULL};

    std::vector< Tuple< int ,std::string  >  >  namedseasons ;
    PyObject* pynamedseasons = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pynamedseasons
       ))
    {
      return NULL;
    }


    try
    {
      
    if (pynamedseasons)
    {
      bool isTuple = PyObject_TypeCheck(pynamedseasons,&PyTuple_Type);
      if (!isTuple && !PyObject_TypeCheck(pynamedseasons,&PyList_Type))
        throw WrongTypeException("The parameter \"namedseasons\" must be either a Tuple or a List.");

      
      PyObject *pyentry1 = NULL;
      Py_ssize_t vecSize = (isTuple ? PyTuple_Size(pynamedseasons) : PyList_Size(pynamedseasons));
      namedseasons.reserve(vecSize);
      for(Py_ssize_t i = 0; i < vecSize; i++)
      {
        pyentry1 = (isTuple ? PyTuple_GetItem(pynamedseasons, i) : PyList_GetItem(pynamedseasons, i));
        Tuple< int ,std::string  >  entry1;
        
    if(pyentry1)
    {
      bool isTuple = PyObject_TypeCheck(pyentry1,&PyTuple_Type);
      if (!isTuple && !PyObject_TypeCheck(pyentry1,&PyList_Type))
        throw WrongTypeException("The parameter \"entry1\" must be either a Tuple or a List.");
      Py_ssize_t vecSize = (isTuple ? PyTuple_Size(pyentry1) : PyList_Size(pyentry1));

      if (vecSize > 0)
      {
        PyObject *pyentry0_2 = NULL;
        pyentry0_2 = (isTuple ? PyTuple_GetItem(pyentry1, 0) : PyList_GetItem(pyentry1, 0));
        int  entry0_2;
        entry0_2 = (int)PyLong_AsLong(pyentry0_2);
        entry1.first() = entry0_2;
      }

      if (vecSize > 1)
      {
        PyObject *pyentry1_2 = NULL;
        pyentry1_2 = (isTuple ? PyTuple_GetItem(pyentry1, 1) : PyList_GetItem(pyentry1, 1));
        std::string  entry1_2;
        if (pyentry1_2) PyXBMCGetUnicodeString(entry1_2,pyentry1_2,false,"entry1_2","addSeasons");
        entry1.second() = entry1_2;
      }

    }

        namedseasons.push_back(std::move(entry1));
      }
    }
 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"addSeasons","XBMCAddon::xbmc::InfoTagVideo"))-> addSeasons(  namedseasons  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"addSeasons\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"addSeasons\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_addVideoStream (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "stream",
          NULL};

    XBMCAddon::xbmc::VideoStreamDetail * stream  = nullptr;
    PyObject* pystream = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pystream
       ))
    {
      return NULL;
    }


    try
    {
      stream = (XBMCAddon::xbmc::VideoStreamDetail *)retrieveApiInstance(pystream,"p.XBMCAddon::xbmc::VideoStreamDetail","XBMCAddon::xbmc::","addVideoStream"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"addVideoStream","XBMCAddon::xbmc::InfoTagVideo"))-> addVideoStream(  stream  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"addVideoStream\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"addVideoStream\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_addAudioStream (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "stream",
          NULL};

    XBMCAddon::xbmc::AudioStreamDetail * stream  = nullptr;
    PyObject* pystream = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pystream
       ))
    {
      return NULL;
    }


    try
    {
      stream = (XBMCAddon::xbmc::AudioStreamDetail *)retrieveApiInstance(pystream,"p.XBMCAddon::xbmc::AudioStreamDetail","XBMCAddon::xbmc::","addAudioStream"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"addAudioStream","XBMCAddon::xbmc::InfoTagVideo"))-> addAudioStream(  stream  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"addAudioStream\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"addAudioStream\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_addSubtitleStream (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "stream",
          NULL};

    XBMCAddon::xbmc::SubtitleStreamDetail * stream  = nullptr;
    PyObject* pystream = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pystream
       ))
    {
      return NULL;
    }


    try
    {
      stream = (XBMCAddon::xbmc::SubtitleStreamDetail *)retrieveApiInstance(pystream,"p.XBMCAddon::xbmc::SubtitleStreamDetail","XBMCAddon::xbmc::","addSubtitleStream"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"addSubtitleStream","XBMCAddon::xbmc::InfoTagVideo"))-> addSubtitleStream(  stream  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"addSubtitleStream\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"addSubtitleStream\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_InfoTagVideo_addAvailableArtwork (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "url",
          "arttype",
          "preview",
          "referrer",
          "cache",
          "post",
          "isgz",
          "season",
          NULL};

    std::string  url ;
    PyObject* pyurl = NULL;
    std::string  arttype  = "";
    PyObject* pyarttype = NULL;
    std::string  preview  = "";
    PyObject* pypreview = NULL;
    std::string  referrer  = "";
    PyObject* pyreferrer = NULL;
    std::string  cache  = "";
    PyObject* pycache = NULL;
    bool  post  = false;
    bool  isgz  = false;
    int  season  = -1;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O|OOOObbi",
       const_cast<char**>(keywords),
         &pyurl,
         &pyarttype,
         &pypreview,
         &pyreferrer,
         &pycache,
         &post,
         &isgz,
         &season
       ))
    {
      return NULL;
    }


    try
    {
      if (pyurl) PyXBMCGetUnicodeString(url,pyurl,false,"url","addAvailableArtwork"); 
      if (pyarttype) PyXBMCGetUnicodeString(arttype,pyarttype,false,"arttype","addAvailableArtwork"); 
      if (pypreview) PyXBMCGetUnicodeString(preview,pypreview,false,"preview","addAvailableArtwork"); 
      if (pyreferrer) PyXBMCGetUnicodeString(referrer,pyreferrer,false,"referrer","addAvailableArtwork"); 
      if (pycache) PyXBMCGetUnicodeString(cache,pycache,false,"cache","addAvailableArtwork"); 

      ((XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"addAvailableArtwork","XBMCAddon::xbmc::InfoTagVideo"))-> addAvailableArtwork(  url,  arttype,  preview,  referrer,  cache,  post,  isgz,  season  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"addAvailableArtwork\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"addAvailableArtwork\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Keyboard_New (PyTypeObject* pytype  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    std::string  line  = XBMCAddon::emptyString;
    PyObject* pyline = NULL;
    std::string  heading  = XBMCAddon::emptyString;
    PyObject* pyheading = NULL;
    bool  hidden  = false;
    if (!PyArg_ParseTuple(
       args,
       
       "|OOb",
       
         &pyline,
         &pyheading,
         &hidden
       ))
    {
      return NULL;
    }

    XBMCAddon::xbmc::Keyboard * apiResult;
    try
    {
      if (pyline) PyXBMCGetUnicodeString(line,pyline,false,"line","Keyboard"); 
      if (pyheading) PyXBMCGetUnicodeString(heading,pyheading,false,"heading","Keyboard"); 

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = new XBMCAddon::xbmc::Keyboard(  line,  heading,  hidden  );
      prepareForReturn(apiResult);
    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"new XBMCAddon::xbmc::Keyboard\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"new XBMCAddon::xbmc::Keyboard\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,pytype,false);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Keyboard_doModal (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "autoclose",
          NULL};

    int  autoclose  = 0;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "|i",
       const_cast<char**>(keywords),
         &autoclose
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::Keyboard*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Keyboard_Type,"doModal","XBMCAddon::xbmc::Keyboard"))-> doModal(  autoclose  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"doModal\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"doModal\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Keyboard_setDefault (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "line",
          NULL};

    std::string  line  = XBMCAddon::emptyString;
    PyObject* pyline = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "|O",
       const_cast<char**>(keywords),
         &pyline
       ))
    {
      return NULL;
    }


    try
    {
      if (pyline) PyXBMCGetUnicodeString(line,pyline,false,"line","setDefault"); 

      ((XBMCAddon::xbmc::Keyboard*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Keyboard_Type,"setDefault","XBMCAddon::xbmc::Keyboard"))-> setDefault(  line  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setDefault\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setDefault\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Keyboard_setHiddenInput (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "hidden",
          NULL};

    bool  hidden  = false;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "|b",
       const_cast<char**>(keywords),
         &hidden
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::Keyboard*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Keyboard_Type,"setHiddenInput","XBMCAddon::xbmc::Keyboard"))-> setHiddenInput(  hidden  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setHiddenInput\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setHiddenInput\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Keyboard_setHeading (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "heading",
          NULL};

    std::string  heading ;
    PyObject* pyheading = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyheading
       ))
    {
      return NULL;
    }


    try
    {
      if (pyheading) PyXBMCGetUnicodeString(heading,pyheading,false,"heading","setHeading"); 

      ((XBMCAddon::xbmc::Keyboard*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Keyboard_Type,"setHeading","XBMCAddon::xbmc::Keyboard"))-> setHeading(  heading  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"setHeading\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"setHeading\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Keyboard_getText (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::String  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Keyboard*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Keyboard_Type,"getText","XBMCAddon::xbmc::Keyboard"))-> getText(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getText\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getText\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Keyboard_isConfirmed (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    bool  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Keyboard*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Keyboard_Type,"isConfirmed","XBMCAddon::xbmc::Keyboard"))-> isConfirmed(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"isConfirmed\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"isConfirmed\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = apiResult ? Py_True : Py_False; Py_INCREF(result);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_PlayList_New (PyTypeObject* pytype  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    int  playList ;
    if (!PyArg_ParseTuple(
       args,
       
       "i",
       
         &playList
       ))
    {
      return NULL;
    }

    XBMCAddon::xbmc::PlayList * apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = new XBMCAddon::xbmc::PlayList(  playList  );
      prepareForReturn(apiResult);
    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"new XBMCAddon::xbmc::PlayList\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"new XBMCAddon::xbmc::PlayList\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,pytype,false);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_PlayList_getPlayListId (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::PlayList*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_PlayList_Type,"getPlayListId","XBMCAddon::xbmc::PlayList"))-> getPlayListId(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getPlayListId\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getPlayListId\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_PlayList_add (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "url",
          "listitem",
          "index",
          NULL};

    std::string  url ;
    PyObject* pyurl = NULL;
    XBMCAddon::xbmcgui::ListItem * listitem  = NULL;
    PyObject* pylistitem = NULL;
    int  index  = -1;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O|Oi",
       const_cast<char**>(keywords),
         &pyurl,
         &pylistitem,
         &index
       ))
    {
      return NULL;
    }


    try
    {
      if (pyurl) PyXBMCGetUnicodeString(url,pyurl,false,"url","add"); 
      listitem = (XBMCAddon::xbmcgui::ListItem *)retrieveApiInstance(pylistitem,"p.XBMCAddon::xbmcgui::ListItem","XBMCAddon::xbmc::","add"); 

      ((XBMCAddon::xbmc::PlayList*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_PlayList_Type,"add","XBMCAddon::xbmc::PlayList"))-> add(  url,  listitem,  index  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"add\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"add\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_PlayList_load (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "filename",
          NULL};

    char * filename  = nullptr;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "s",
       const_cast<char**>(keywords),
         &filename
       ))
    {
      return NULL;
    }

    bool  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::PlayList*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_PlayList_Type,"load","XBMCAddon::xbmc::PlayList"))-> load(  filename  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"load\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"load\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = apiResult ? Py_True : Py_False; Py_INCREF(result);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_PlayList_remove (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "filename",
          NULL};

    char * filename  = nullptr;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "s",
       const_cast<char**>(keywords),
         &filename
       ))
    {
      return NULL;
    }


    try
    {

      ((XBMCAddon::xbmc::PlayList*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_PlayList_Type,"remove","XBMCAddon::xbmc::PlayList"))-> remove(  filename  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"remove\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"remove\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_PlayList_clear (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      ((XBMCAddon::xbmc::PlayList*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_PlayList_Type,"clear","XBMCAddon::xbmc::PlayList"))-> clear(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"clear\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"clear\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_PlayList_size (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::PlayList*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_PlayList_Type,"size","XBMCAddon::xbmc::PlayList"))-> size(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"size\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"size\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_PlayList_shuffle (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      ((XBMCAddon::xbmc::PlayList*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_PlayList_Type,"shuffle","XBMCAddon::xbmc::PlayList"))-> shuffle(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"shuffle\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"shuffle\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_PlayList_unshuffle (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      ((XBMCAddon::xbmc::PlayList*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_PlayList_Type,"unshuffle","XBMCAddon::xbmc::PlayList"))-> unshuffle(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"unshuffle\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"unshuffle\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_PlayList_getposition (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    int  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::PlayList*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_PlayList_Type,"getposition","XBMCAddon::xbmc::PlayList"))-> getposition(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"getposition\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"getposition\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = Py_BuildValue("i", apiResult);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_PlayList_operatorIndex_ (PyHolder* self , PyObject* pyi )
  {
    XBMC_TRACE;

    long  i ;    XBMCAddon::xbmcgui::ListItem * apiResult;
    try
    {
      i = PyLong_AsLong(pyi); 

      apiResult = ((XBMCAddon::xbmc::PlayList*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_PlayList_Type,"operator []","XBMCAddon::xbmc::PlayList"))-> operator [](  i  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"operator []\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"operator []\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,true);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Monitor_New (PyTypeObject* pytype  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    XBMCAddon::xbmc::Monitor * apiResult;
    try
    {

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = (&(TyXBMCAddon_xbmc_Monitor_Type.pythonType) != pytype) ? new XBMCAddon_xbmc_Monitor_Director() : new XBMCAddon::xbmc::Monitor(  );
      prepareForReturn(apiResult);
    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"new XBMCAddon::xbmc::Monitor\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"new XBMCAddon::xbmc::Monitor\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,pytype,false);
    if (&(TyXBMCAddon_xbmc_Monitor_Type.pythonType) != pytype)
      ((XBMCAddon_xbmc_Monitor_Director*)apiResult)->setPyObjectForDirector(result);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Monitor_onSettingsChanged (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Monitor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Monitor_Type,"onSettingsChanged","XBMCAddon::xbmc::Monitor"))-> XBMCAddon::xbmc::Monitor::onSettingsChanged(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onSettingsChanged\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onSettingsChanged\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Monitor_onScreensaverActivated (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Monitor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Monitor_Type,"onScreensaverActivated","XBMCAddon::xbmc::Monitor"))-> XBMCAddon::xbmc::Monitor::onScreensaverActivated(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onScreensaverActivated\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onScreensaverActivated\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Monitor_onScreensaverDeactivated (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Monitor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Monitor_Type,"onScreensaverDeactivated","XBMCAddon::xbmc::Monitor"))-> XBMCAddon::xbmc::Monitor::onScreensaverDeactivated(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onScreensaverDeactivated\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onScreensaverDeactivated\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Monitor_onDPMSActivated (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Monitor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Monitor_Type,"onDPMSActivated","XBMCAddon::xbmc::Monitor"))-> XBMCAddon::xbmc::Monitor::onDPMSActivated(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onDPMSActivated\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onDPMSActivated\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Monitor_onDPMSDeactivated (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Monitor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Monitor_Type,"onDPMSDeactivated","XBMCAddon::xbmc::Monitor"))-> XBMCAddon::xbmc::Monitor::onDPMSDeactivated(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onDPMSDeactivated\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onDPMSDeactivated\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Monitor_onScanStarted (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "library",
          NULL};

    std::string  library ;
    PyObject* pylibrary = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pylibrary
       ))
    {
      return NULL;
    }


    try
    {
      if (pylibrary) PyXBMCGetUnicodeString(library,pylibrary,false,"library","onScanStarted"); 

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Monitor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Monitor_Type,"onScanStarted","XBMCAddon::xbmc::Monitor"))-> XBMCAddon::xbmc::Monitor::onScanStarted(  library  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onScanStarted\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onScanStarted\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Monitor_onScanFinished (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "library",
          NULL};

    std::string  library ;
    PyObject* pylibrary = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pylibrary
       ))
    {
      return NULL;
    }


    try
    {
      if (pylibrary) PyXBMCGetUnicodeString(library,pylibrary,false,"library","onScanFinished"); 

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Monitor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Monitor_Type,"onScanFinished","XBMCAddon::xbmc::Monitor"))-> XBMCAddon::xbmc::Monitor::onScanFinished(  library  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onScanFinished\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onScanFinished\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Monitor_onCleanStarted (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "library",
          NULL};

    std::string  library ;
    PyObject* pylibrary = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pylibrary
       ))
    {
      return NULL;
    }


    try
    {
      if (pylibrary) PyXBMCGetUnicodeString(library,pylibrary,false,"library","onCleanStarted"); 

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Monitor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Monitor_Type,"onCleanStarted","XBMCAddon::xbmc::Monitor"))-> XBMCAddon::xbmc::Monitor::onCleanStarted(  library  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onCleanStarted\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onCleanStarted\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Monitor_onCleanFinished (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "library",
          NULL};

    std::string  library ;
    PyObject* pylibrary = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pylibrary
       ))
    {
      return NULL;
    }


    try
    {
      if (pylibrary) PyXBMCGetUnicodeString(library,pylibrary,false,"library","onCleanFinished"); 

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Monitor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Monitor_Type,"onCleanFinished","XBMCAddon::xbmc::Monitor"))-> XBMCAddon::xbmc::Monitor::onCleanFinished(  library  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onCleanFinished\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onCleanFinished\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Monitor_onNotification (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "sender",
          "method",
          "data",
          NULL};

    std::string  sender ;
    PyObject* pysender = NULL;
    std::string  method ;
    PyObject* pymethod = NULL;
    std::string  data ;
    PyObject* pydata = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "OOO",
       const_cast<char**>(keywords),
         &pysender,
         &pymethod,
         &pydata
       ))
    {
      return NULL;
    }


    try
    {
      if (pysender) PyXBMCGetUnicodeString(sender,pysender,false,"sender","onNotification"); 
      if (pymethod) PyXBMCGetUnicodeString(method,pymethod,false,"method","onNotification"); 
      if (pydata) PyXBMCGetUnicodeString(data,pydata,false,"data","onNotification"); 

      // This is a director call coming from python so it explicitly calls the base class method.
      ((XBMCAddon::xbmc::Monitor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Monitor_Type,"onNotification","XBMCAddon::xbmc::Monitor"))-> XBMCAddon::xbmc::Monitor::onNotification(  sender,  method,  data  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"onNotification\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"onNotification\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Monitor_waitForAbort (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "timeout",
          NULL};

    double  timeout  = -1;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "|d",
       const_cast<char**>(keywords),
         &timeout
       ))
    {
      return NULL;
    }

    bool  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Monitor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Monitor_Type,"waitForAbort","XBMCAddon::xbmc::Monitor"))-> waitForAbort(  timeout  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"waitForAbort\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"waitForAbort\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = apiResult ? Py_True : Py_False; Py_INCREF(result);

    return result; 
  } 

  static PyObject* xbmc_XBMCAddon_xbmc_Monitor_abortRequested (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;
    bool  apiResult;
    try
    {

      apiResult = ((XBMCAddon::xbmc::Monitor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Monitor_Type,"abortRequested","XBMCAddon::xbmc::Monitor"))-> abortRequested(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"abortRequested\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"abortRequested\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = apiResult ? Py_True : Py_False; Py_INCREF(result);

    return result; 
  } 

  static void xbmc_XBMCAddon_xbmc_Player_Dealloc (PyHolder* self  )
  {
    XBMC_TRACE;

    try
    {


      XBMCAddon::xbmc::Player* theObj = (XBMCAddon::xbmc::Player*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Player_Type,"~XBMCAddon::xbmc::Player","XBMCAddon::xbmc::Player");
      cleanForDealloc(theObj);

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::Player\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::Player\""); 
    }

    (((PyObject*)(self))->ob_type)->tp_free((PyObject*)self);
    
  } 
  static void xbmc_XBMCAddon_xbmc_RenderCapture_Dealloc (PyHolder* self  )
  {
    XBMC_TRACE;

    try
    {


      XBMCAddon::xbmc::RenderCapture* theObj = (XBMCAddon::xbmc::RenderCapture*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_RenderCapture_Type,"~XBMCAddon::xbmc::RenderCapture","XBMCAddon::xbmc::RenderCapture");
      cleanForDealloc(theObj);

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::RenderCapture\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::RenderCapture\""); 
    }

    (((PyObject*)(self))->ob_type)->tp_free((PyObject*)self);
    
  } 
  static void xbmc_XBMCAddon_xbmc_InfoTagGame_Dealloc (PyHolder* self  )
  {
    XBMC_TRACE;

    try
    {


      XBMCAddon::xbmc::InfoTagGame* theObj = (XBMCAddon::xbmc::InfoTagGame*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagGame_Type,"~XBMCAddon::xbmc::InfoTagGame","XBMCAddon::xbmc::InfoTagGame");
      cleanForDealloc(theObj);

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::InfoTagGame\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::InfoTagGame\""); 
    }

    (((PyObject*)(self))->ob_type)->tp_free((PyObject*)self);
    
  } 
  static void xbmc_XBMCAddon_xbmc_InfoTagMusic_Dealloc (PyHolder* self  )
  {
    XBMC_TRACE;

    try
    {


      XBMCAddon::xbmc::InfoTagMusic* theObj = (XBMCAddon::xbmc::InfoTagMusic*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagMusic_Type,"~XBMCAddon::xbmc::InfoTagMusic","XBMCAddon::xbmc::InfoTagMusic");
      cleanForDealloc(theObj);

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::InfoTagMusic\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::InfoTagMusic\""); 
    }

    (((PyObject*)(self))->ob_type)->tp_free((PyObject*)self);
    
  } 
  static void xbmc_XBMCAddon_xbmc_InfoTagPicture_Dealloc (PyHolder* self  )
  {
    XBMC_TRACE;

    try
    {


      XBMCAddon::xbmc::InfoTagPicture* theObj = (XBMCAddon::xbmc::InfoTagPicture*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagPicture_Type,"~XBMCAddon::xbmc::InfoTagPicture","XBMCAddon::xbmc::InfoTagPicture");
      cleanForDealloc(theObj);

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::InfoTagPicture\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::InfoTagPicture\""); 
    }

    (((PyObject*)(self))->ob_type)->tp_free((PyObject*)self);
    
  } 
  static void xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_Dealloc (PyHolder* self  )
  {
    XBMC_TRACE;

    try
    {


      XBMCAddon::xbmc::InfoTagRadioRDS* theObj = (XBMCAddon::xbmc::InfoTagRadioRDS*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type,"~XBMCAddon::xbmc::InfoTagRadioRDS","XBMCAddon::xbmc::InfoTagRadioRDS");
      cleanForDealloc(theObj);

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::InfoTagRadioRDS\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::InfoTagRadioRDS\""); 
    }

    (((PyObject*)(self))->ob_type)->tp_free((PyObject*)self);
    
  } 
  static void xbmc_XBMCAddon_xbmc_Actor_Dealloc (PyHolder* self  )
  {
    XBMC_TRACE;

    try
    {


      XBMCAddon::xbmc::Actor* theObj = (XBMCAddon::xbmc::Actor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Actor_Type,"~XBMCAddon::xbmc::Actor","XBMCAddon::xbmc::Actor");
      cleanForDealloc(theObj);

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::Actor\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::Actor\""); 
    }

    (((PyObject*)(self))->ob_type)->tp_free((PyObject*)self);
    
  } 
  static void xbmc_XBMCAddon_xbmc_VideoStreamDetail_Dealloc (PyHolder* self  )
  {
    XBMC_TRACE;

    try
    {


      XBMCAddon::xbmc::VideoStreamDetail* theObj = (XBMCAddon::xbmc::VideoStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_VideoStreamDetail_Type,"~XBMCAddon::xbmc::VideoStreamDetail","XBMCAddon::xbmc::VideoStreamDetail");
      cleanForDealloc(theObj);

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::VideoStreamDetail\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::VideoStreamDetail\""); 
    }

    (((PyObject*)(self))->ob_type)->tp_free((PyObject*)self);
    
  } 
  static void xbmc_XBMCAddon_xbmc_AudioStreamDetail_Dealloc (PyHolder* self  )
  {
    XBMC_TRACE;

    try
    {


      XBMCAddon::xbmc::AudioStreamDetail* theObj = (XBMCAddon::xbmc::AudioStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_AudioStreamDetail_Type,"~XBMCAddon::xbmc::AudioStreamDetail","XBMCAddon::xbmc::AudioStreamDetail");
      cleanForDealloc(theObj);

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::AudioStreamDetail\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::AudioStreamDetail\""); 
    }

    (((PyObject*)(self))->ob_type)->tp_free((PyObject*)self);
    
  } 
  static void xbmc_XBMCAddon_xbmc_SubtitleStreamDetail_Dealloc (PyHolder* self  )
  {
    XBMC_TRACE;

    try
    {


      XBMCAddon::xbmc::SubtitleStreamDetail* theObj = (XBMCAddon::xbmc::SubtitleStreamDetail*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_SubtitleStreamDetail_Type,"~XBMCAddon::xbmc::SubtitleStreamDetail","XBMCAddon::xbmc::SubtitleStreamDetail");
      cleanForDealloc(theObj);

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::SubtitleStreamDetail\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::SubtitleStreamDetail\""); 
    }

    (((PyObject*)(self))->ob_type)->tp_free((PyObject*)self);
    
  } 
  static void xbmc_XBMCAddon_xbmc_InfoTagVideo_Dealloc (PyHolder* self  )
  {
    XBMC_TRACE;

    try
    {


      XBMCAddon::xbmc::InfoTagVideo* theObj = (XBMCAddon::xbmc::InfoTagVideo*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_InfoTagVideo_Type,"~XBMCAddon::xbmc::InfoTagVideo","XBMCAddon::xbmc::InfoTagVideo");
      cleanForDealloc(theObj);

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::InfoTagVideo\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::InfoTagVideo\""); 
    }

    (((PyObject*)(self))->ob_type)->tp_free((PyObject*)self);
    
  } 
  static void xbmc_XBMCAddon_xbmc_Keyboard_Dealloc (PyHolder* self  )
  {
    XBMC_TRACE;

    try
    {


      XBMCAddon::xbmc::Keyboard* theObj = (XBMCAddon::xbmc::Keyboard*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Keyboard_Type,"~XBMCAddon::xbmc::Keyboard","XBMCAddon::xbmc::Keyboard");
      cleanForDealloc(theObj);

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::Keyboard\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::Keyboard\""); 
    }

    (((PyObject*)(self))->ob_type)->tp_free((PyObject*)self);
    
  } 
  static void xbmc_XBMCAddon_xbmc_PlayList_Dealloc (PyHolder* self  )
  {
    XBMC_TRACE;

    try
    {


      XBMCAddon::xbmc::PlayList* theObj = (XBMCAddon::xbmc::PlayList*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_PlayList_Type,"~XBMCAddon::xbmc::PlayList","XBMCAddon::xbmc::PlayList");
      cleanForDealloc(theObj);

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::PlayList\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::PlayList\""); 
    }

    (((PyObject*)(self))->ob_type)->tp_free((PyObject*)self);
    
  } 
  static void xbmc_XBMCAddon_xbmc_Monitor_Dealloc (PyHolder* self  )
  {
    XBMC_TRACE;

    try
    {


      XBMCAddon::xbmc::Monitor* theObj = (XBMCAddon::xbmc::Monitor*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmc_Monitor_Type,"~XBMCAddon::xbmc::Monitor","XBMCAddon::xbmc::Monitor");
      cleanForDealloc(theObj);

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmc::Monitor\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmc::Monitor\""); 
    }

    (((PyObject*)(self))->ob_type)->tp_free((PyObject*)self);
    
  } 
  //=========================================================================
  // This section contains the initialization for the
  // Python extension for the Api class XBMCAddon::xbmc::Player
  //=========================================================================
  // All of the methods on this class
  static PyMethodDef XBMCAddon_xbmc_Player_methods[] = { 
    {"play", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_play, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"stop", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_stop, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"pause", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_pause, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"playnext", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_playnext, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"playprevious", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_playprevious, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"playselected", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_playselected, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"launchURI", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_launchURI, METH_VARARGS | METH_KEYWORDS, NULL },
    {"onPlayBackStarted", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_onPlayBackStarted, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"onAVStarted", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_onAVStarted, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"onAVChange", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_onAVChange, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"onPlayBackEnded", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_onPlayBackEnded, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"onPlayBackStopped", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_onPlayBackStopped, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"onPlayBackError", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_onPlayBackError, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"onPlayBackPaused", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_onPlayBackPaused, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"onPlayBackResumed", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_onPlayBackResumed, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"onQueueNextItem", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_onQueueNextItem, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"onPlayBackSpeedChanged", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_onPlayBackSpeedChanged, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"onPlayBackSeek", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_onPlayBackSeek, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"onPlayBackSeekChapter", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_onPlayBackSeekChapter, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"isPlaying", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_isPlaying, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"isPlayingAudio", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_isPlayingAudio, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"isPlayingVideo", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_isPlayingVideo, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"isPlayingRDS", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_isPlayingRDS, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"isExternalPlayer", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_isExternalPlayer, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getPlayingFile", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_getPlayingFile, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getPlayingItem", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_getPlayingItem, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getTime", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_getTime, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"seekTime", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_seekTime, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setSubtitles", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_setSubtitles, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"showSubtitles", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_showSubtitles, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getSubtitles", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_getSubtitles, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getAvailableSubtitleStreams", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_getAvailableSubtitleStreams, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setSubtitleStream", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_setSubtitleStream, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"updateInfoTag", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_updateInfoTag, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getVideoInfoTag", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_getVideoInfoTag, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getMusicInfoTag", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_getMusicInfoTag, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getRadioRDSInfoTag", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_getRadioRDSInfoTag, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getTotalTime", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_getTotalTime, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getAvailableAudioStreams", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_getAvailableAudioStreams, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setAudioStream", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_setAudioStream, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getAvailableVideoStreams", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_getAvailableVideoStreams, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setVideoStream", (PyCFunction)xbmc_XBMCAddon_xbmc_Player_setVideoStream, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {NULL, NULL, 0, NULL}
  };



  // This method initializes the above mentioned Python Type structure
  static void initPyXBMCAddon_xbmc_Player_Type()
  {


    PyTypeObject& pythonType = TyXBMCAddon_xbmc_Player_Type.pythonType;
    pythonType.tp_name = "xbmc.Player";
    pythonType.tp_basicsize = sizeof(PyHolder);
    pythonType.tp_dealloc = (destructor)xbmc_XBMCAddon_xbmc_Player_Dealloc; 

    pythonType.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;

    pythonType.tp_doc = NULL;
    pythonType.tp_methods = XBMCAddon_xbmc_Player_methods; 

    pythonType.tp_base = NULL;
    pythonType.tp_new = xbmc_XBMCAddon_xbmc_Player_New;
    pythonType.tp_init = dummy_tp_init;

    TyXBMCAddon_xbmc_Player_Type.swigType="p.XBMCAddon::xbmc::Player";
    registerAddonClassTypeInformation(&TyXBMCAddon_xbmc_Player_Type);

  }
  //=========================================================================

  //=========================================================================
  // This section contains the initialization for the
  // Python extension for the Api class XBMCAddon::xbmc::RenderCapture
  //=========================================================================
  // All of the methods on this class
  static PyMethodDef XBMCAddon_xbmc_RenderCapture_methods[] = { 
    {"getWidth", (PyCFunction)xbmc_XBMCAddon_xbmc_RenderCapture_getWidth, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getHeight", (PyCFunction)xbmc_XBMCAddon_xbmc_RenderCapture_getHeight, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getAspectRatio", (PyCFunction)xbmc_XBMCAddon_xbmc_RenderCapture_getAspectRatio, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getImageFormat", (PyCFunction)xbmc_XBMCAddon_xbmc_RenderCapture_getImageFormat, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getImage", (PyCFunction)xbmc_XBMCAddon_xbmc_RenderCapture_getImage, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"capture", (PyCFunction)xbmc_XBMCAddon_xbmc_RenderCapture_capture, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {NULL, NULL, 0, NULL}
  };



  // This method initializes the above mentioned Python Type structure
  static void initPyXBMCAddon_xbmc_RenderCapture_Type()
  {


    PyTypeObject& pythonType = TyXBMCAddon_xbmc_RenderCapture_Type.pythonType;
    pythonType.tp_name = "xbmc.RenderCapture";
    pythonType.tp_basicsize = sizeof(PyHolder);
    pythonType.tp_dealloc = (destructor)xbmc_XBMCAddon_xbmc_RenderCapture_Dealloc; 

    pythonType.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;

    pythonType.tp_doc = NULL;
    pythonType.tp_methods = XBMCAddon_xbmc_RenderCapture_methods; 

    pythonType.tp_base = NULL;
    pythonType.tp_new = xbmc_XBMCAddon_xbmc_RenderCapture_New;
    pythonType.tp_init = dummy_tp_init;

    TyXBMCAddon_xbmc_RenderCapture_Type.swigType="p.XBMCAddon::xbmc::RenderCapture";
    registerAddonClassTypeInformation(&TyXBMCAddon_xbmc_RenderCapture_Type);

  }
  //=========================================================================

  //=========================================================================
  // This section contains the initialization for the
  // Python extension for the Api class XBMCAddon::xbmc::InfoTagGame
  //=========================================================================
  // All of the methods on this class
  static PyMethodDef XBMCAddon_xbmc_InfoTagGame_methods[] = { 
    {"getTitle", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagGame_getTitle, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getPlatform", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagGame_getPlatform, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getGenres", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagGame_getGenres, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getPublisher", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagGame_getPublisher, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getDeveloper", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagGame_getDeveloper, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getOverview", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagGame_getOverview, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getYear", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagGame_getYear, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getGameClient", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagGame_getGameClient, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setTitle", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagGame_setTitle, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setPlatform", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagGame_setPlatform, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setGenres", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagGame_setGenres, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setPublisher", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagGame_setPublisher, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setDeveloper", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagGame_setDeveloper, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setOverview", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagGame_setOverview, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setYear", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagGame_setYear, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setGameClient", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagGame_setGameClient, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {NULL, NULL, 0, NULL}
  };



  // This method initializes the above mentioned Python Type structure
  static void initPyXBMCAddon_xbmc_InfoTagGame_Type()
  {


    PyTypeObject& pythonType = TyXBMCAddon_xbmc_InfoTagGame_Type.pythonType;
    pythonType.tp_name = "xbmc.InfoTagGame";
    pythonType.tp_basicsize = sizeof(PyHolder);
    pythonType.tp_dealloc = (destructor)xbmc_XBMCAddon_xbmc_InfoTagGame_Dealloc; 

    pythonType.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;

    pythonType.tp_doc = NULL;
    pythonType.tp_methods = XBMCAddon_xbmc_InfoTagGame_methods; 

    pythonType.tp_base = NULL;
    pythonType.tp_new = xbmc_XBMCAddon_xbmc_InfoTagGame_New;
    pythonType.tp_init = dummy_tp_init;

    TyXBMCAddon_xbmc_InfoTagGame_Type.swigType="p.XBMCAddon::xbmc::InfoTagGame";
    registerAddonClassTypeInformation(&TyXBMCAddon_xbmc_InfoTagGame_Type);

  }
  //=========================================================================

  //=========================================================================
  // This section contains the initialization for the
  // Python extension for the Api class XBMCAddon::xbmc::InfoTagMusic
  //=========================================================================
  // All of the methods on this class
  static PyMethodDef XBMCAddon_xbmc_InfoTagMusic_methods[] = { 
    {"getDbId", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getDbId, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getURL", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getURL, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getTitle", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getTitle, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getMediaType", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getMediaType, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getArtist", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getArtist, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getAlbum", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getAlbum, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getAlbumArtist", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getAlbumArtist, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getGenre", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getGenre, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getGenres", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getGenres, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getDuration", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getDuration, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getYear", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getYear, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getRating", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getRating, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getUserRating", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getUserRating, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getTrack", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getTrack, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getDisc", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getDisc, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getReleaseDate", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getReleaseDate, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getListeners", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getListeners, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getPlayCount", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getPlayCount, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getLastPlayed", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getLastPlayed, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getLastPlayedAsW3C", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getLastPlayedAsW3C, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getComment", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getComment, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getLyrics", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getLyrics, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getMusicBrainzTrackID", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getMusicBrainzTrackID, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getMusicBrainzArtistID", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getMusicBrainzArtistID, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getMusicBrainzAlbumID", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getMusicBrainzAlbumID, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getMusicBrainzReleaseGroupID", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getMusicBrainzReleaseGroupID, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getMusicBrainzAlbumArtistID", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_getMusicBrainzAlbumArtistID, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setDbId", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setDbId, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setURL", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setURL, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setMediaType", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setMediaType, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setTrack", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setTrack, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setDisc", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setDisc, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setDuration", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setDuration, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setYear", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setYear, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setReleaseDate", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setReleaseDate, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setListeners", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setListeners, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setPlayCount", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setPlayCount, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setGenres", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setGenres, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setAlbum", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setAlbum, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setArtist", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setArtist, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setAlbumArtist", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setAlbumArtist, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setTitle", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setTitle, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setRating", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setRating, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setUserRating", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setUserRating, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setLyrics", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setLyrics, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setLastPlayed", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setLastPlayed, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setMusicBrainzTrackID", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setMusicBrainzTrackID, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setMusicBrainzArtistID", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setMusicBrainzArtistID, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setMusicBrainzAlbumID", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setMusicBrainzAlbumID, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setMusicBrainzReleaseGroupID", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setMusicBrainzReleaseGroupID, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setMusicBrainzAlbumArtistID", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setMusicBrainzAlbumArtistID, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setComment", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagMusic_setComment, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {NULL, NULL, 0, NULL}
  };



  // This method initializes the above mentioned Python Type structure
  static void initPyXBMCAddon_xbmc_InfoTagMusic_Type()
  {


    PyTypeObject& pythonType = TyXBMCAddon_xbmc_InfoTagMusic_Type.pythonType;
    pythonType.tp_name = "xbmc.InfoTagMusic";
    pythonType.tp_basicsize = sizeof(PyHolder);
    pythonType.tp_dealloc = (destructor)xbmc_XBMCAddon_xbmc_InfoTagMusic_Dealloc; 

    pythonType.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;

    pythonType.tp_doc = NULL;
    pythonType.tp_methods = XBMCAddon_xbmc_InfoTagMusic_methods; 

    pythonType.tp_base = NULL;
    pythonType.tp_new = xbmc_XBMCAddon_xbmc_InfoTagMusic_New;
    pythonType.tp_init = dummy_tp_init;

    TyXBMCAddon_xbmc_InfoTagMusic_Type.swigType="p.XBMCAddon::xbmc::InfoTagMusic";
    registerAddonClassTypeInformation(&TyXBMCAddon_xbmc_InfoTagMusic_Type);

  }
  //=========================================================================

  //=========================================================================
  // This section contains the initialization for the
  // Python extension for the Api class XBMCAddon::xbmc::InfoTagPicture
  //=========================================================================
  // All of the methods on this class
  static PyMethodDef XBMCAddon_xbmc_InfoTagPicture_methods[] = { 
    {"getResolution", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagPicture_getResolution, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getDateTimeTaken", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagPicture_getDateTimeTaken, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setResolution", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagPicture_setResolution, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setDateTimeTaken", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagPicture_setDateTimeTaken, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {NULL, NULL, 0, NULL}
  };



  // This method initializes the above mentioned Python Type structure
  static void initPyXBMCAddon_xbmc_InfoTagPicture_Type()
  {


    PyTypeObject& pythonType = TyXBMCAddon_xbmc_InfoTagPicture_Type.pythonType;
    pythonType.tp_name = "xbmc.InfoTagPicture";
    pythonType.tp_basicsize = sizeof(PyHolder);
    pythonType.tp_dealloc = (destructor)xbmc_XBMCAddon_xbmc_InfoTagPicture_Dealloc; 

    pythonType.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;

    pythonType.tp_doc = NULL;
    pythonType.tp_methods = XBMCAddon_xbmc_InfoTagPicture_methods; 

    pythonType.tp_base = NULL;
    pythonType.tp_new = xbmc_XBMCAddon_xbmc_InfoTagPicture_New;
    pythonType.tp_init = dummy_tp_init;

    TyXBMCAddon_xbmc_InfoTagPicture_Type.swigType="p.XBMCAddon::xbmc::InfoTagPicture";
    registerAddonClassTypeInformation(&TyXBMCAddon_xbmc_InfoTagPicture_Type);

  }
  //=========================================================================

  //=========================================================================
  // This section contains the initialization for the
  // Python extension for the Api class XBMCAddon::xbmc::InfoTagRadioRDS
  //=========================================================================
  // All of the methods on this class
  static PyMethodDef XBMCAddon_xbmc_InfoTagRadioRDS_methods[] = { 
    {"getTitle", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getTitle, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getBand", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getBand, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getArtist", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getArtist, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getComposer", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getComposer, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getConductor", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getConductor, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getAlbum", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getAlbum, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getComment", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getComment, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getAlbumTrackNumber", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getAlbumTrackNumber, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getInfoNews", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getInfoNews, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getInfoNewsLocal", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getInfoNewsLocal, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getInfoSport", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getInfoSport, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getInfoStock", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getInfoStock, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getInfoWeather", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getInfoWeather, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getInfoHoroscope", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getInfoHoroscope, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getInfoCinema", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getInfoCinema, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getInfoLottery", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getInfoLottery, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getInfoOther", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getInfoOther, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getEditorialStaff", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getEditorialStaff, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getProgStation", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getProgStation, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getProgStyle", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getProgStyle, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getProgHost", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getProgHost, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getProgWebsite", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getProgWebsite, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getProgNow", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getProgNow, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getProgNext", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getProgNext, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getPhoneHotline", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getPhoneHotline, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getEMailHotline", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getEMailHotline, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getPhoneStudio", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getPhoneStudio, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getEMailStudio", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getEMailStudio, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getSMSStudio", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_getSMSStudio, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {NULL, NULL, 0, NULL}
  };



  // This method initializes the above mentioned Python Type structure
  static void initPyXBMCAddon_xbmc_InfoTagRadioRDS_Type()
  {


    PyTypeObject& pythonType = TyXBMCAddon_xbmc_InfoTagRadioRDS_Type.pythonType;
    pythonType.tp_name = "xbmc.InfoTagRadioRDS";
    pythonType.tp_basicsize = sizeof(PyHolder);
    pythonType.tp_dealloc = (destructor)xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_Dealloc; 

    pythonType.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;

    pythonType.tp_doc = NULL;
    pythonType.tp_methods = XBMCAddon_xbmc_InfoTagRadioRDS_methods; 

    pythonType.tp_base = NULL;
    pythonType.tp_new = xbmc_XBMCAddon_xbmc_InfoTagRadioRDS_New;
    pythonType.tp_init = dummy_tp_init;

    TyXBMCAddon_xbmc_InfoTagRadioRDS_Type.swigType="p.XBMCAddon::xbmc::InfoTagRadioRDS";
    registerAddonClassTypeInformation(&TyXBMCAddon_xbmc_InfoTagRadioRDS_Type);

  }
  //=========================================================================

  //=========================================================================
  // This section contains the initialization for the
  // Python extension for the Api class XBMCAddon::xbmc::Actor
  //=========================================================================
  // All of the methods on this class
  static PyMethodDef XBMCAddon_xbmc_Actor_methods[] = { 
    {"getName", (PyCFunction)xbmc_XBMCAddon_xbmc_Actor_getName, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getRole", (PyCFunction)xbmc_XBMCAddon_xbmc_Actor_getRole, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getOrder", (PyCFunction)xbmc_XBMCAddon_xbmc_Actor_getOrder, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getThumbnail", (PyCFunction)xbmc_XBMCAddon_xbmc_Actor_getThumbnail, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setName", (PyCFunction)xbmc_XBMCAddon_xbmc_Actor_setName, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setRole", (PyCFunction)xbmc_XBMCAddon_xbmc_Actor_setRole, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setOrder", (PyCFunction)xbmc_XBMCAddon_xbmc_Actor_setOrder, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setThumbnail", (PyCFunction)xbmc_XBMCAddon_xbmc_Actor_setThumbnail, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {NULL, NULL, 0, NULL}
  };



  // This method initializes the above mentioned Python Type structure
  static void initPyXBMCAddon_xbmc_Actor_Type()
  {


    PyTypeObject& pythonType = TyXBMCAddon_xbmc_Actor_Type.pythonType;
    pythonType.tp_name = "xbmc.Actor";
    pythonType.tp_basicsize = sizeof(PyHolder);
    pythonType.tp_dealloc = (destructor)xbmc_XBMCAddon_xbmc_Actor_Dealloc; 

    pythonType.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;

    pythonType.tp_doc = NULL;
    pythonType.tp_methods = XBMCAddon_xbmc_Actor_methods; 

    pythonType.tp_base = NULL;
    pythonType.tp_new = xbmc_XBMCAddon_xbmc_Actor_New;
    pythonType.tp_init = dummy_tp_init;

    TyXBMCAddon_xbmc_Actor_Type.swigType="p.XBMCAddon::xbmc::Actor";
    registerAddonClassTypeInformation(&TyXBMCAddon_xbmc_Actor_Type);

  }
  //=========================================================================

  //=========================================================================
  // This section contains the initialization for the
  // Python extension for the Api class XBMCAddon::xbmc::VideoStreamDetail
  //=========================================================================
  // All of the methods on this class
  static PyMethodDef XBMCAddon_xbmc_VideoStreamDetail_methods[] = { 
    {"getWidth", (PyCFunction)xbmc_XBMCAddon_xbmc_VideoStreamDetail_getWidth, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getHeight", (PyCFunction)xbmc_XBMCAddon_xbmc_VideoStreamDetail_getHeight, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getAspect", (PyCFunction)xbmc_XBMCAddon_xbmc_VideoStreamDetail_getAspect, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getDuration", (PyCFunction)xbmc_XBMCAddon_xbmc_VideoStreamDetail_getDuration, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getCodec", (PyCFunction)xbmc_XBMCAddon_xbmc_VideoStreamDetail_getCodec, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getStereoMode", (PyCFunction)xbmc_XBMCAddon_xbmc_VideoStreamDetail_getStereoMode, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getLanguage", (PyCFunction)xbmc_XBMCAddon_xbmc_VideoStreamDetail_getLanguage, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getHDRType", (PyCFunction)xbmc_XBMCAddon_xbmc_VideoStreamDetail_getHDRType, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setWidth", (PyCFunction)xbmc_XBMCAddon_xbmc_VideoStreamDetail_setWidth, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setHeight", (PyCFunction)xbmc_XBMCAddon_xbmc_VideoStreamDetail_setHeight, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setAspect", (PyCFunction)xbmc_XBMCAddon_xbmc_VideoStreamDetail_setAspect, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setDuration", (PyCFunction)xbmc_XBMCAddon_xbmc_VideoStreamDetail_setDuration, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setCodec", (PyCFunction)xbmc_XBMCAddon_xbmc_VideoStreamDetail_setCodec, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setStereoMode", (PyCFunction)xbmc_XBMCAddon_xbmc_VideoStreamDetail_setStereoMode, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setLanguage", (PyCFunction)xbmc_XBMCAddon_xbmc_VideoStreamDetail_setLanguage, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setHDRType", (PyCFunction)xbmc_XBMCAddon_xbmc_VideoStreamDetail_setHDRType, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {NULL, NULL, 0, NULL}
  };



  // This method initializes the above mentioned Python Type structure
  static void initPyXBMCAddon_xbmc_VideoStreamDetail_Type()
  {


    PyTypeObject& pythonType = TyXBMCAddon_xbmc_VideoStreamDetail_Type.pythonType;
    pythonType.tp_name = "xbmc.VideoStreamDetail";
    pythonType.tp_basicsize = sizeof(PyHolder);
    pythonType.tp_dealloc = (destructor)xbmc_XBMCAddon_xbmc_VideoStreamDetail_Dealloc; 

    pythonType.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;

    pythonType.tp_doc = NULL;
    pythonType.tp_methods = XBMCAddon_xbmc_VideoStreamDetail_methods; 

    pythonType.tp_base = NULL;
    pythonType.tp_new = xbmc_XBMCAddon_xbmc_VideoStreamDetail_New;
    pythonType.tp_init = dummy_tp_init;

    TyXBMCAddon_xbmc_VideoStreamDetail_Type.swigType="p.XBMCAddon::xbmc::VideoStreamDetail";
    registerAddonClassTypeInformation(&TyXBMCAddon_xbmc_VideoStreamDetail_Type);

  }
  //=========================================================================

  //=========================================================================
  // This section contains the initialization for the
  // Python extension for the Api class XBMCAddon::xbmc::AudioStreamDetail
  //=========================================================================
  // All of the methods on this class
  static PyMethodDef XBMCAddon_xbmc_AudioStreamDetail_methods[] = { 
    {"getChannels", (PyCFunction)xbmc_XBMCAddon_xbmc_AudioStreamDetail_getChannels, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getCodec", (PyCFunction)xbmc_XBMCAddon_xbmc_AudioStreamDetail_getCodec, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getLanguage", (PyCFunction)xbmc_XBMCAddon_xbmc_AudioStreamDetail_getLanguage, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setChannels", (PyCFunction)xbmc_XBMCAddon_xbmc_AudioStreamDetail_setChannels, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setCodec", (PyCFunction)xbmc_XBMCAddon_xbmc_AudioStreamDetail_setCodec, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setLanguage", (PyCFunction)xbmc_XBMCAddon_xbmc_AudioStreamDetail_setLanguage, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {NULL, NULL, 0, NULL}
  };



  // This method initializes the above mentioned Python Type structure
  static void initPyXBMCAddon_xbmc_AudioStreamDetail_Type()
  {


    PyTypeObject& pythonType = TyXBMCAddon_xbmc_AudioStreamDetail_Type.pythonType;
    pythonType.tp_name = "xbmc.AudioStreamDetail";
    pythonType.tp_basicsize = sizeof(PyHolder);
    pythonType.tp_dealloc = (destructor)xbmc_XBMCAddon_xbmc_AudioStreamDetail_Dealloc; 

    pythonType.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;

    pythonType.tp_doc = NULL;
    pythonType.tp_methods = XBMCAddon_xbmc_AudioStreamDetail_methods; 

    pythonType.tp_base = NULL;
    pythonType.tp_new = xbmc_XBMCAddon_xbmc_AudioStreamDetail_New;
    pythonType.tp_init = dummy_tp_init;

    TyXBMCAddon_xbmc_AudioStreamDetail_Type.swigType="p.XBMCAddon::xbmc::AudioStreamDetail";
    registerAddonClassTypeInformation(&TyXBMCAddon_xbmc_AudioStreamDetail_Type);

  }
  //=========================================================================

  //=========================================================================
  // This section contains the initialization for the
  // Python extension for the Api class XBMCAddon::xbmc::SubtitleStreamDetail
  //=========================================================================
  // All of the methods on this class
  static PyMethodDef XBMCAddon_xbmc_SubtitleStreamDetail_methods[] = { 
    {"getLanguage", (PyCFunction)xbmc_XBMCAddon_xbmc_SubtitleStreamDetail_getLanguage, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setLanguage", (PyCFunction)xbmc_XBMCAddon_xbmc_SubtitleStreamDetail_setLanguage, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {NULL, NULL, 0, NULL}
  };



  // This method initializes the above mentioned Python Type structure
  static void initPyXBMCAddon_xbmc_SubtitleStreamDetail_Type()
  {


    PyTypeObject& pythonType = TyXBMCAddon_xbmc_SubtitleStreamDetail_Type.pythonType;
    pythonType.tp_name = "xbmc.SubtitleStreamDetail";
    pythonType.tp_basicsize = sizeof(PyHolder);
    pythonType.tp_dealloc = (destructor)xbmc_XBMCAddon_xbmc_SubtitleStreamDetail_Dealloc; 

    pythonType.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;

    pythonType.tp_doc = NULL;
    pythonType.tp_methods = XBMCAddon_xbmc_SubtitleStreamDetail_methods; 

    pythonType.tp_base = NULL;
    pythonType.tp_new = xbmc_XBMCAddon_xbmc_SubtitleStreamDetail_New;
    pythonType.tp_init = dummy_tp_init;

    TyXBMCAddon_xbmc_SubtitleStreamDetail_Type.swigType="p.XBMCAddon::xbmc::SubtitleStreamDetail";
    registerAddonClassTypeInformation(&TyXBMCAddon_xbmc_SubtitleStreamDetail_Type);

  }
  //=========================================================================

  //=========================================================================
  // This section contains the initialization for the
  // Python extension for the Api class XBMCAddon::xbmc::InfoTagVideo
  //=========================================================================
  // All of the methods on this class
  static PyMethodDef XBMCAddon_xbmc_InfoTagVideo_methods[] = { 
    {"getDbId", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getDbId, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getDirector", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getDirector, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getDirectors", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getDirectors, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getWritingCredits", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getWritingCredits, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getWriters", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getWriters, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getGenre", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getGenre, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getGenres", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getGenres, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getTagLine", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getTagLine, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getPlotOutline", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getPlotOutline, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getPlot", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getPlot, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getPictureURL", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getPictureURL, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getTitle", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getTitle, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getTVShowTitle", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getTVShowTitle, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getMediaType", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getMediaType, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getVotes", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getVotes, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getVotesAsInt", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getVotesAsInt, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getCast", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getCast, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getActors", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getActors, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getFile", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getFile, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getPath", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getPath, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getFilenameAndPath", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getFilenameAndPath, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getIMDBNumber", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getIMDBNumber, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getSeason", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getSeason, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getEpisode", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getEpisode, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getYear", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getYear, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getRating", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getRating, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getUserRating", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getUserRating, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getPlayCount", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getPlayCount, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getLastPlayed", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getLastPlayed, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getLastPlayedAsW3C", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getLastPlayedAsW3C, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getOriginalTitle", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getOriginalTitle, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getPremiered", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getPremiered, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getPremieredAsW3C", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getPremieredAsW3C, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getFirstAired", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getFirstAired, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getFirstAiredAsW3C", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getFirstAiredAsW3C, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getTrailer", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getTrailer, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getArtist", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getArtist, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getAlbum", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getAlbum, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getTrack", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getTrack, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getDuration", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getDuration, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getResumeTime", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getResumeTime, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getResumeTimeTotal", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getResumeTimeTotal, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getUniqueID", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_getUniqueID, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setUniqueID", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setUniqueID, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setUniqueIDs", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setUniqueIDs, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setDbId", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setDbId, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setYear", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setYear, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setEpisode", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setEpisode, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setSeason", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setSeason, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setSortEpisode", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setSortEpisode, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setSortSeason", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setSortSeason, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setEpisodeGuide", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setEpisodeGuide, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setTop250", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setTop250, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setSetId", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setSetId, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setTrackNumber", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setTrackNumber, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setRating", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setRating, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setRatings", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setRatings, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setUserRating", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setUserRating, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setPlaycount", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setPlaycount, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setMpaa", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setMpaa, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setPlot", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setPlot, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setPlotOutline", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setPlotOutline, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setTitle", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setTitle, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setOriginalTitle", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setOriginalTitle, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setSortTitle", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setSortTitle, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setTagLine", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setTagLine, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setTvShowTitle", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setTvShowTitle, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setTvShowStatus", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setTvShowStatus, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setGenres", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setGenres, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setCountries", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setCountries, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setDirectors", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setDirectors, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setStudios", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setStudios, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setWriters", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setWriters, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setDuration", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setDuration, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setPremiered", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setPremiered, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setSet", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setSet, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setSetOverview", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setSetOverview, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setTags", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setTags, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setProductionCode", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setProductionCode, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setFirstAired", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setFirstAired, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setLastPlayed", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setLastPlayed, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setAlbum", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setAlbum, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setVotes", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setVotes, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setTrailer", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setTrailer, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setPath", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setPath, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setFilenameAndPath", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setFilenameAndPath, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setIMDBNumber", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setIMDBNumber, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setDateAdded", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setDateAdded, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setMediaType", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setMediaType, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setShowLinks", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setShowLinks, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setArtists", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setArtists, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setCast", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setCast, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setResumePoint", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_setResumePoint, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"addSeason", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_addSeason, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"addSeasons", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_addSeasons, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"addVideoStream", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_addVideoStream, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"addAudioStream", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_addAudioStream, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"addSubtitleStream", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_addSubtitleStream, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"addAvailableArtwork", (PyCFunction)xbmc_XBMCAddon_xbmc_InfoTagVideo_addAvailableArtwork, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {NULL, NULL, 0, NULL}
  };



  // This method initializes the above mentioned Python Type structure
  static void initPyXBMCAddon_xbmc_InfoTagVideo_Type()
  {


    PyTypeObject& pythonType = TyXBMCAddon_xbmc_InfoTagVideo_Type.pythonType;
    pythonType.tp_name = "xbmc.InfoTagVideo";
    pythonType.tp_basicsize = sizeof(PyHolder);
    pythonType.tp_dealloc = (destructor)xbmc_XBMCAddon_xbmc_InfoTagVideo_Dealloc; 

    pythonType.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;

    pythonType.tp_doc = NULL;
    pythonType.tp_methods = XBMCAddon_xbmc_InfoTagVideo_methods; 

    pythonType.tp_base = NULL;
    pythonType.tp_new = xbmc_XBMCAddon_xbmc_InfoTagVideo_New;
    pythonType.tp_init = dummy_tp_init;

    TyXBMCAddon_xbmc_InfoTagVideo_Type.swigType="p.XBMCAddon::xbmc::InfoTagVideo";
    registerAddonClassTypeInformation(&TyXBMCAddon_xbmc_InfoTagVideo_Type);

  }
  //=========================================================================

  //=========================================================================
  // This section contains the initialization for the
  // Python extension for the Api class XBMCAddon::xbmc::Keyboard
  //=========================================================================
  // All of the methods on this class
  static PyMethodDef XBMCAddon_xbmc_Keyboard_methods[] = { 
    {"doModal", (PyCFunction)xbmc_XBMCAddon_xbmc_Keyboard_doModal, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setDefault", (PyCFunction)xbmc_XBMCAddon_xbmc_Keyboard_setDefault, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setHiddenInput", (PyCFunction)xbmc_XBMCAddon_xbmc_Keyboard_setHiddenInput, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"setHeading", (PyCFunction)xbmc_XBMCAddon_xbmc_Keyboard_setHeading, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getText", (PyCFunction)xbmc_XBMCAddon_xbmc_Keyboard_getText, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"isConfirmed", (PyCFunction)xbmc_XBMCAddon_xbmc_Keyboard_isConfirmed, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {NULL, NULL, 0, NULL}
  };



  // This method initializes the above mentioned Python Type structure
  static void initPyXBMCAddon_xbmc_Keyboard_Type()
  {


    PyTypeObject& pythonType = TyXBMCAddon_xbmc_Keyboard_Type.pythonType;
    pythonType.tp_name = "xbmc.Keyboard";
    pythonType.tp_basicsize = sizeof(PyHolder);
    pythonType.tp_dealloc = (destructor)xbmc_XBMCAddon_xbmc_Keyboard_Dealloc; 

    pythonType.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;

    pythonType.tp_doc = NULL;
    pythonType.tp_methods = XBMCAddon_xbmc_Keyboard_methods; 

    pythonType.tp_base = NULL;
    pythonType.tp_new = xbmc_XBMCAddon_xbmc_Keyboard_New;
    pythonType.tp_init = dummy_tp_init;

    TyXBMCAddon_xbmc_Keyboard_Type.swigType="p.XBMCAddon::xbmc::Keyboard";
    registerAddonClassTypeInformation(&TyXBMCAddon_xbmc_Keyboard_Type);

  }
  //=========================================================================

  static Py_ssize_t xbmc_XBMCAddon_xbmc_PlayList_size_(PyObject* self)
  {
    return (Py_ssize_t)((XBMCAddon::xbmc::PlayList*)retrieveApiInstance(self,&TyXBMCAddon_xbmc_PlayList_Type,"operator []","XBMCAddon::xbmc::PlayList"))-> size();
  }

  //=========================================================================
  // tp_as_mapping struct for XBMCAddon::xbmc::PlayList
  //=========================================================================
  PyMappingMethods xbmc_XBMCAddon_xbmc_PlayList_as_mapping = {
    xbmc_XBMCAddon_xbmc_PlayList_size_,    /* inquiry mp_length;                  __len__ */
    (PyCFunction)xbmc_XBMCAddon_xbmc_PlayList_operatorIndex_,   /* binaryfunc mp_subscript             __getitem__ */
    0,                  /* objargproc mp_ass_subscript;     __setitem__ */
  };

  //=========================================================================
  // This section contains the initialization for the
  // Python extension for the Api class XBMCAddon::xbmc::PlayList
  //=========================================================================
  // All of the methods on this class
  static PyMethodDef XBMCAddon_xbmc_PlayList_methods[] = { 
    {"getPlayListId", (PyCFunction)xbmc_XBMCAddon_xbmc_PlayList_getPlayListId, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"add", (PyCFunction)xbmc_XBMCAddon_xbmc_PlayList_add, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"load", (PyCFunction)xbmc_XBMCAddon_xbmc_PlayList_load, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"remove", (PyCFunction)xbmc_XBMCAddon_xbmc_PlayList_remove, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"clear", (PyCFunction)xbmc_XBMCAddon_xbmc_PlayList_clear, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"size", (PyCFunction)xbmc_XBMCAddon_xbmc_PlayList_size, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"shuffle", (PyCFunction)xbmc_XBMCAddon_xbmc_PlayList_shuffle, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"unshuffle", (PyCFunction)xbmc_XBMCAddon_xbmc_PlayList_unshuffle, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getposition", (PyCFunction)xbmc_XBMCAddon_xbmc_PlayList_getposition, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {NULL, NULL, 0, NULL}
  };



  // This method initializes the above mentioned Python Type structure
  static void initPyXBMCAddon_xbmc_PlayList_Type()
  {


    PyTypeObject& pythonType = TyXBMCAddon_xbmc_PlayList_Type.pythonType;
    pythonType.tp_name = "xbmc.PlayList";
    pythonType.tp_basicsize = sizeof(PyHolder);
    pythonType.tp_dealloc = (destructor)xbmc_XBMCAddon_xbmc_PlayList_Dealloc; 

    pythonType.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;

    pythonType.tp_doc = NULL;
    pythonType.tp_methods = XBMCAddon_xbmc_PlayList_methods; 
    pythonType.tp_as_mapping = &xbmc_XBMCAddon_xbmc_PlayList_as_mapping;


    pythonType.tp_base = NULL;
    pythonType.tp_new = xbmc_XBMCAddon_xbmc_PlayList_New;
    pythonType.tp_init = dummy_tp_init;

    TyXBMCAddon_xbmc_PlayList_Type.swigType="p.XBMCAddon::xbmc::PlayList";
    registerAddonClassTypeInformation(&TyXBMCAddon_xbmc_PlayList_Type);

  }
  //=========================================================================

  //=========================================================================
  // This section contains the initialization for the
  // Python extension for the Api class XBMCAddon::xbmc::Monitor
  //=========================================================================
  // All of the methods on this class
  static PyMethodDef XBMCAddon_xbmc_Monitor_methods[] = { 
    {"onSettingsChanged", (PyCFunction)xbmc_XBMCAddon_xbmc_Monitor_onSettingsChanged, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"onScreensaverActivated", (PyCFunction)xbmc_XBMCAddon_xbmc_Monitor_onScreensaverActivated, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"onScreensaverDeactivated", (PyCFunction)xbmc_XBMCAddon_xbmc_Monitor_onScreensaverDeactivated, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"onDPMSActivated", (PyCFunction)xbmc_XBMCAddon_xbmc_Monitor_onDPMSActivated, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"onDPMSDeactivated", (PyCFunction)xbmc_XBMCAddon_xbmc_Monitor_onDPMSDeactivated, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"onScanStarted", (PyCFunction)xbmc_XBMCAddon_xbmc_Monitor_onScanStarted, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"onScanFinished", (PyCFunction)xbmc_XBMCAddon_xbmc_Monitor_onScanFinished, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"onCleanStarted", (PyCFunction)xbmc_XBMCAddon_xbmc_Monitor_onCleanStarted, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"onCleanFinished", (PyCFunction)xbmc_XBMCAddon_xbmc_Monitor_onCleanFinished, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"onNotification", (PyCFunction)xbmc_XBMCAddon_xbmc_Monitor_onNotification, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"waitForAbort", (PyCFunction)xbmc_XBMCAddon_xbmc_Monitor_waitForAbort, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"abortRequested", (PyCFunction)xbmc_XBMCAddon_xbmc_Monitor_abortRequested, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {NULL, NULL, 0, NULL}
  };



  // This method initializes the above mentioned Python Type structure
  static void initPyXBMCAddon_xbmc_Monitor_Type()
  {


    PyTypeObject& pythonType = TyXBMCAddon_xbmc_Monitor_Type.pythonType;
    pythonType.tp_name = "xbmc.Monitor";
    pythonType.tp_basicsize = sizeof(PyHolder);
    pythonType.tp_dealloc = (destructor)xbmc_XBMCAddon_xbmc_Monitor_Dealloc; 

    pythonType.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;

    pythonType.tp_doc = NULL;
    pythonType.tp_methods = XBMCAddon_xbmc_Monitor_methods; 

    pythonType.tp_base = NULL;
    pythonType.tp_new = xbmc_XBMCAddon_xbmc_Monitor_New;
    pythonType.tp_init = dummy_tp_init;

    TyXBMCAddon_xbmc_Monitor_Type.swigType="p.XBMCAddon::xbmc::Monitor";
    registerAddonClassTypeInformation(&TyXBMCAddon_xbmc_Monitor_Type);

  }
  //=========================================================================


  static PyMethodDef xbmc_methods[] = { 
    {"log", (PyCFunction)xbmc_log, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"shutdown", (PyCFunction)xbmc_shutdown, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"restart", (PyCFunction)xbmc_restart, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"executescript", (PyCFunction)xbmc_executescript, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"executebuiltin", (PyCFunction)xbmc_executebuiltin, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"executeJSONRPC", (PyCFunction)xbmc_executeJSONRPC, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"sleep", (PyCFunction)xbmc_sleep, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getLocalizedString", (PyCFunction)xbmc_getLocalizedString, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getSkinDir", (PyCFunction)xbmc_getSkinDir, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getLanguage", (PyCFunction)xbmc_getLanguage, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getIPAddress", (PyCFunction)xbmc_getIPAddress, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getDVDState", (PyCFunction)xbmc_getDVDState, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getFreeMem", (PyCFunction)xbmc_getFreeMem, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getInfoLabel", (PyCFunction)xbmc_getInfoLabel, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getInfoImage", (PyCFunction)xbmc_getInfoImage, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"playSFX", (PyCFunction)xbmc_playSFX, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"stopSFX", (PyCFunction)xbmc_stopSFX, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"enableNavSounds", (PyCFunction)xbmc_enableNavSounds, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getCondVisibility", (PyCFunction)xbmc_getCondVisibility, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getGlobalIdleTime", (PyCFunction)xbmc_getGlobalIdleTime, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getCacheThumbName", (PyCFunction)xbmc_getCacheThumbName, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getCleanMovieTitle", (PyCFunction)xbmc_getCleanMovieTitle, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getRegion", (PyCFunction)xbmc_getRegion, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getSupportedMedia", (PyCFunction)xbmc_getSupportedMedia, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"skinHasImage", (PyCFunction)xbmc_skinHasImage, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"startServer", (PyCFunction)xbmc_startServer, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"audioSuspend", (PyCFunction)xbmc_audioSuspend, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"audioResume", (PyCFunction)xbmc_audioResume, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"getUserAgent", (PyCFunction)xbmc_getUserAgent, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"convertLanguage", (PyCFunction)xbmc_convertLanguage, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {NULL, NULL, 0, NULL}
  };

  // This is the call that will call all of the other initializes
  //  for all of the classes in this module
  static void initTypes()
  {
    static bool typesAlreadyInitialized = false;
    if (!typesAlreadyInitialized)
    {
      typesAlreadyInitialized = true;

      initPyXBMCAddon_xbmc_Player_Type();
      initPyXBMCAddon_xbmc_RenderCapture_Type();
      initPyXBMCAddon_xbmc_InfoTagGame_Type();
      initPyXBMCAddon_xbmc_InfoTagMusic_Type();
      initPyXBMCAddon_xbmc_InfoTagPicture_Type();
      initPyXBMCAddon_xbmc_InfoTagRadioRDS_Type();
      initPyXBMCAddon_xbmc_Actor_Type();
      initPyXBMCAddon_xbmc_VideoStreamDetail_Type();
      initPyXBMCAddon_xbmc_AudioStreamDetail_Type();
      initPyXBMCAddon_xbmc_SubtitleStreamDetail_Type();
      initPyXBMCAddon_xbmc_InfoTagVideo_Type();
      initPyXBMCAddon_xbmc_Keyboard_Type();
      initPyXBMCAddon_xbmc_PlayList_Type();
      initPyXBMCAddon_xbmc_Monitor_Type();
      if (PyType_Ready(&(TyXBMCAddon_xbmc_Player_Type.pythonType)) < 0)
        return;
      if (PyType_Ready(&(TyXBMCAddon_xbmc_RenderCapture_Type.pythonType)) < 0)
        return;
      if (PyType_Ready(&(TyXBMCAddon_xbmc_InfoTagGame_Type.pythonType)) < 0)
        return;
      if (PyType_Ready(&(TyXBMCAddon_xbmc_InfoTagMusic_Type.pythonType)) < 0)
        return;
      if (PyType_Ready(&(TyXBMCAddon_xbmc_InfoTagPicture_Type.pythonType)) < 0)
        return;
      if (PyType_Ready(&(TyXBMCAddon_xbmc_InfoTagRadioRDS_Type.pythonType)) < 0)
        return;
      if (PyType_Ready(&(TyXBMCAddon_xbmc_Actor_Type.pythonType)) < 0)
        return;
      if (PyType_Ready(&(TyXBMCAddon_xbmc_VideoStreamDetail_Type.pythonType)) < 0)
        return;
      if (PyType_Ready(&(TyXBMCAddon_xbmc_AudioStreamDetail_Type.pythonType)) < 0)
        return;
      if (PyType_Ready(&(TyXBMCAddon_xbmc_SubtitleStreamDetail_Type.pythonType)) < 0)
        return;
      if (PyType_Ready(&(TyXBMCAddon_xbmc_InfoTagVideo_Type.pythonType)) < 0)
        return;
      if (PyType_Ready(&(TyXBMCAddon_xbmc_Keyboard_Type.pythonType)) < 0)
        return;
      if (PyType_Ready(&(TyXBMCAddon_xbmc_PlayList_Type.pythonType)) < 0)
        return;
      if (PyType_Ready(&(TyXBMCAddon_xbmc_Monitor_Type.pythonType)) < 0)
        return;
    }
  }

  static struct PyModuleDef createModule
  {
      PyModuleDef_HEAD_INIT,
      "xbmc",
      "",
      -1,
      xbmc_methods,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
  };

  PyObject *PyInit_Module_xbmc()
  {
    initTypes();

    // init general xbmc modules
    PyObject* module;


    Py_INCREF(&(TyXBMCAddon_xbmc_Player_Type.pythonType));
    Py_INCREF(&(TyXBMCAddon_xbmc_RenderCapture_Type.pythonType));
    Py_INCREF(&(TyXBMCAddon_xbmc_InfoTagGame_Type.pythonType));
    Py_INCREF(&(TyXBMCAddon_xbmc_InfoTagMusic_Type.pythonType));
    Py_INCREF(&(TyXBMCAddon_xbmc_InfoTagPicture_Type.pythonType));
    Py_INCREF(&(TyXBMCAddon_xbmc_InfoTagRadioRDS_Type.pythonType));
    Py_INCREF(&(TyXBMCAddon_xbmc_Actor_Type.pythonType));
    Py_INCREF(&(TyXBMCAddon_xbmc_VideoStreamDetail_Type.pythonType));
    Py_INCREF(&(TyXBMCAddon_xbmc_AudioStreamDetail_Type.pythonType));
    Py_INCREF(&(TyXBMCAddon_xbmc_SubtitleStreamDetail_Type.pythonType));
    Py_INCREF(&(TyXBMCAddon_xbmc_InfoTagVideo_Type.pythonType));
    Py_INCREF(&(TyXBMCAddon_xbmc_Keyboard_Type.pythonType));
    Py_INCREF(&(TyXBMCAddon_xbmc_PlayList_Type.pythonType));
    Py_INCREF(&(TyXBMCAddon_xbmc_Monitor_Type.pythonType));

    module = PyModule_Create(&createModule);
    if (module == NULL) return NULL;


    PyModule_AddObject(module, "Player", (PyObject*)(&(TyXBMCAddon_xbmc_Player_Type.pythonType)));
    PyModule_AddObject(module, "RenderCapture", (PyObject*)(&(TyXBMCAddon_xbmc_RenderCapture_Type.pythonType)));
    PyModule_AddObject(module, "InfoTagGame", (PyObject*)(&(TyXBMCAddon_xbmc_InfoTagGame_Type.pythonType)));
    PyModule_AddObject(module, "InfoTagMusic", (PyObject*)(&(TyXBMCAddon_xbmc_InfoTagMusic_Type.pythonType)));
    PyModule_AddObject(module, "InfoTagPicture", (PyObject*)(&(TyXBMCAddon_xbmc_InfoTagPicture_Type.pythonType)));
    PyModule_AddObject(module, "InfoTagRadioRDS", (PyObject*)(&(TyXBMCAddon_xbmc_InfoTagRadioRDS_Type.pythonType)));
    PyModule_AddObject(module, "Actor", (PyObject*)(&(TyXBMCAddon_xbmc_Actor_Type.pythonType)));
    PyModule_AddObject(module, "VideoStreamDetail", (PyObject*)(&(TyXBMCAddon_xbmc_VideoStreamDetail_Type.pythonType)));
    PyModule_AddObject(module, "AudioStreamDetail", (PyObject*)(&(TyXBMCAddon_xbmc_AudioStreamDetail_Type.pythonType)));
    PyModule_AddObject(module, "SubtitleStreamDetail", (PyObject*)(&(TyXBMCAddon_xbmc_SubtitleStreamDetail_Type.pythonType)));
    PyModule_AddObject(module, "InfoTagVideo", (PyObject*)(&(TyXBMCAddon_xbmc_InfoTagVideo_Type.pythonType)));
    PyModule_AddObject(module, "Keyboard", (PyObject*)(&(TyXBMCAddon_xbmc_Keyboard_Type.pythonType)));
    PyModule_AddObject(module, "PlayList", (PyObject*)(&(TyXBMCAddon_xbmc_PlayList_Type.pythonType)));
    PyModule_AddObject(module, "Monitor", (PyObject*)(&(TyXBMCAddon_xbmc_Monitor_Type.pythonType)));

   // constants
   PyModule_AddStringConstant(module, "__author__", "Team Kodi <http://kodi.tv>");
   PyModule_AddStringConstant(module, "__date__", CCompileInfo::GetBuildDate().c_str());
   PyModule_AddStringConstant(module, "__version__", "3.0.1");
   PyModule_AddStringConstant(module, "__credits__", "Team Kodi");
   PyModule_AddStringConstant(module, "__platform__", "ALL");

   // need to handle constants
   // #define constants

   PyModule_AddIntConstant(module,"SERVER_WEBSERVER",getSERVER_WEBSERVER()); 
   PyModule_AddIntConstant(module,"SERVER_AIRPLAYSERVER",getSERVER_AIRPLAYSERVER()); 
   PyModule_AddIntConstant(module,"SERVER_UPNPSERVER",getSERVER_UPNPSERVER()); 
   PyModule_AddIntConstant(module,"SERVER_UPNPRENDERER",getSERVER_UPNPRENDERER()); 
   PyModule_AddIntConstant(module,"SERVER_EVENTSERVER",getSERVER_EVENTSERVER()); 
   PyModule_AddIntConstant(module,"SERVER_JSONRPCSERVER",getSERVER_JSONRPCSERVER()); 
   PyModule_AddIntConstant(module,"SERVER_ZEROCONF",getSERVER_ZEROCONF()); 
   PyModule_AddIntConstant(module,"PLAYLIST_MUSIC",getPLAYLIST_MUSIC()); 
   PyModule_AddIntConstant(module,"PLAYLIST_VIDEO",getPLAYLIST_VIDEO()); 
   PyModule_AddIntConstant(module,"TRAY_OPEN",getTRAY_OPEN()); 
   PyModule_AddIntConstant(module,"DRIVE_NOT_READY",getDRIVE_NOT_READY()); 
   PyModule_AddIntConstant(module,"TRAY_CLOSED_NO_MEDIA",getTRAY_CLOSED_NO_MEDIA()); 
   PyModule_AddIntConstant(module,"TRAY_CLOSED_MEDIA_PRESENT",getTRAY_CLOSED_MEDIA_PRESENT()); 
   PyModule_AddIntConstant(module,"LOGDEBUG",getLOGDEBUG()); 
   PyModule_AddIntConstant(module,"LOGINFO",getLOGINFO()); 
   PyModule_AddIntConstant(module,"LOGWARNING",getLOGWARNING()); 
   PyModule_AddIntConstant(module,"LOGERROR",getLOGERROR()); 
   PyModule_AddIntConstant(module,"LOGFATAL",getLOGFATAL()); 
   PyModule_AddIntConstant(module,"LOGNONE",getLOGNONE()); 
   PyModule_AddIntConstant(module,"ISO_639_1",getISO_639_1()); 
   PyModule_AddIntConstant(module,"ISO_639_2",getISO_639_2()); 
   PyModule_AddIntConstant(module,"ENGLISH_NAME",getENGLISH_NAME()); 
  // constexpr constants

  return module;
  }

} // end PythonBindings namespace for python type definitions


