

/*
 *  Copyright (C) 2005-2018 Team Kodi
 *  This file is part of Kodi - https://kodi.tv
 *
 *  SPDX-License-Identifier: GPL-2.0-or-later
 *  See LICENSES/README.md for more information.
 */

// ************************************************************************
// This file was generated by xbmc compile process. DO NOT EDIT!!
//  It was created by running the code generator on the spec file for
//  the module "xbmcdrm" on the template file PythonSwig.template.cpp
// ************************************************************************



#include <Python.h>
#include <string>
#include "CompileInfo.h"
#include "interfaces/python/LanguageHook.h"
#include "interfaces/python/swig.h"
#include "interfaces/python/PyContext.h"


#if defined(TARGET_WINDOWS)
#  include <windows.h>
#endif

#include "interfaces/legacy/DrmCryptoSession.h"
#include "utils/log.h"

using namespace XBMCAddon;
using namespace xbmcdrm;

#if defined(__GNUG__)
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif



namespace PythonBindings
{

  //=========================================================================
  // These variables will hold the Python Type information for XBMCAddon::xbmcdrm::CryptoSession
  TypeInfo TyXBMCAddon_xbmcdrm_CryptoSession_Type(typeid(XBMCAddon::xbmcdrm::CryptoSession));
  //=========================================================================



  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_New (PyTypeObject* pytype  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "UUID",
          "cipherAlgorithm",
          "macAlgorithm",
          NULL};

    std::string  UUID ;
    PyObject* pyUUID = NULL;
    std::string  cipherAlgorithm ;
    PyObject* pycipherAlgorithm = NULL;
    std::string  macAlgorithm ;
    PyObject* pymacAlgorithm = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "OOO",
       const_cast<char**>(keywords),
         &pyUUID,
         &pycipherAlgorithm,
         &pymacAlgorithm
       ))
    {
      return NULL;
    }

    XBMCAddon::xbmcdrm::CryptoSession * apiResult;
    try
    {
      if (pyUUID) PyXBMCGetUnicodeString(UUID,pyUUID,false,"UUID","CryptoSession"); 
      if (pycipherAlgorithm) PyXBMCGetUnicodeString(cipherAlgorithm,pycipherAlgorithm,false,"cipherAlgorithm","CryptoSession"); 
      if (pymacAlgorithm) PyXBMCGetUnicodeString(macAlgorithm,pymacAlgorithm,false,"macAlgorithm","CryptoSession"); 

      XBMCAddon::SetLanguageHookGuard slhg(XBMCAddon::Python::PythonLanguageHook::GetIfExists(PyThreadState_Get()->interp).get());
      apiResult = new XBMCAddon::xbmcdrm::CryptoSession(  UUID,  cipherAlgorithm,  macAlgorithm  );
      prepareForReturn(apiResult);
    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"new XBMCAddon::xbmcdrm::CryptoSession\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"new XBMCAddon::xbmcdrm::CryptoSession\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = makePythonInstance(apiResult,pytype,false);

    return result; 
  } 

  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_GetKeyRequest (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "init",
          "mimeType",
          "offlineKey",
          "optionalParameters",
          NULL};

    XbmcCommons::Buffer  init ;
    PyObject* pyinit = NULL;
    std::string  mimeType ;
    PyObject* pymimeType = NULL;
    bool  offlineKey ;
    std::map< XBMCAddon::String ,XBMCAddon::String  >  optionalParameters ;
    PyObject* pyoptionalParameters = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "OObO",
       const_cast<char**>(keywords),
         &pyinit,
         &pymimeType,
         &offlineKey,
         &pyoptionalParameters
       ))
    {
      return NULL;
    }

    XbmcCommons::Buffer  apiResult;
    try
    {
      
    if (PyUnicode_Check(pyinit))
    {
      Py_ssize_t pysize;
      const char* str = PyUnicode_AsUTF8AndSize(pyinit, &pysize);
      size_t size = static_cast<size_t>(pysize);
      init.allocate(size);
      init.put(str, size);
      init.flip(); // prepare the buffer for reading from
    }
    else if (PyBytes_Check(pyinit))
    {
      Py_ssize_t pysize = PyBytes_GET_SIZE(pyinit);
      const char* str = PyBytes_AS_STRING(pyinit);
      size_t size = static_cast<size_t>(pysize);
      init.allocate(size);
      init.put(str, size);
      init.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pyinit))
    {
      size_t size = PyByteArray_Size(pyinit);
      init.allocate(size);
      init.put(PyByteArray_AsString(pyinit),size);
      init.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string, bytes or a bytearray", "init", "GetKeyRequest"); 
      if (pymimeType) PyXBMCGetUnicodeString(mimeType,pymimeType,false,"mimeType","GetKeyRequest"); 
      
    {
      PyObject *pykey, *pyvalue;
      Py_ssize_t pos = 0;
      while(PyDict_Next(pyoptionalParameters, &pos, &pykey, &pyvalue))
      {
        std::string  key;
        std::string  value;
        if (pykey) PyXBMCGetUnicodeString(key,pykey,false,"key","GetKeyRequest");
        if (pyvalue) PyXBMCGetUnicodeString(value,pyvalue,false,"value","GetKeyRequest");
        optionalParameters.emplace(std::move(key), std::move(value));
      }
    } 

      apiResult = ((XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"GetKeyRequest","XBMCAddon::xbmcdrm::CryptoSession"))-> GetKeyRequest(  init,  mimeType,  offlineKey,  optionalParameters  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"GetKeyRequest\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"GetKeyRequest\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyByteArray_FromStringAndSize((char*)apiResult.curPosition(),apiResult.remaining());

    return result; 
  } 

  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_GetPropertyString (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "name",
          NULL};

    std::string  name ;
    PyObject* pyname = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyname
       ))
    {
      return NULL;
    }

    XBMCAddon::String  apiResult;
    try
    {
      if (pyname) PyXBMCGetUnicodeString(name,pyname,false,"name","GetPropertyString"); 

      apiResult = ((XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"GetPropertyString","XBMCAddon::xbmcdrm::CryptoSession"))-> GetPropertyString(  name  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"GetPropertyString\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"GetPropertyString\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_ProvideKeyResponse (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "response",
          NULL};

    XbmcCommons::Buffer  response ;
    PyObject* pyresponse = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pyresponse
       ))
    {
      return NULL;
    }

    XBMCAddon::String  apiResult;
    try
    {
      
    if (PyUnicode_Check(pyresponse))
    {
      Py_ssize_t pysize;
      const char* str = PyUnicode_AsUTF8AndSize(pyresponse, &pysize);
      size_t size = static_cast<size_t>(pysize);
      response.allocate(size);
      response.put(str, size);
      response.flip(); // prepare the buffer for reading from
    }
    else if (PyBytes_Check(pyresponse))
    {
      Py_ssize_t pysize = PyBytes_GET_SIZE(pyresponse);
      const char* str = PyBytes_AS_STRING(pyresponse);
      size_t size = static_cast<size_t>(pysize);
      response.allocate(size);
      response.put(str, size);
      response.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pyresponse))
    {
      size_t size = PyByteArray_Size(pyresponse);
      response.allocate(size);
      response.put(PyByteArray_AsString(pyresponse),size);
      response.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string, bytes or a bytearray", "response", "ProvideKeyResponse"); 

      apiResult = ((XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"ProvideKeyResponse","XBMCAddon::xbmcdrm::CryptoSession"))-> ProvideKeyResponse(  response  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"ProvideKeyResponse\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"ProvideKeyResponse\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyUnicode_DecodeUTF8(apiResult.c_str(),apiResult.size(),"surrogateescape");


    return result; 
  } 

  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_RemoveKeys (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    try
    {

      ((XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"RemoveKeys","XBMCAddon::xbmcdrm::CryptoSession"))-> RemoveKeys(  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"RemoveKeys\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"RemoveKeys\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_RestoreKeys (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "keySetId",
          NULL};

    std::string  keySetId ;
    PyObject* pykeySetId = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "O",
       const_cast<char**>(keywords),
         &pykeySetId
       ))
    {
      return NULL;
    }


    try
    {
      if (pykeySetId) PyXBMCGetUnicodeString(keySetId,pykeySetId,false,"keySetId","RestoreKeys"); 

      ((XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"RestoreKeys","XBMCAddon::xbmcdrm::CryptoSession"))-> RestoreKeys(  keySetId  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"RestoreKeys\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"RestoreKeys\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_SetPropertyString (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "name",
          "value",
          NULL};

    std::string  name ;
    PyObject* pyname = NULL;
    std::string  value ;
    PyObject* pyvalue = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "OO",
       const_cast<char**>(keywords),
         &pyname,
         &pyvalue
       ))
    {
      return NULL;
    }


    try
    {
      if (pyname) PyXBMCGetUnicodeString(name,pyname,false,"name","SetPropertyString"); 
      if (pyvalue) PyXBMCGetUnicodeString(value,pyvalue,false,"value","SetPropertyString"); 

      ((XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"SetPropertyString","XBMCAddon::xbmcdrm::CryptoSession"))-> SetPropertyString(  name,  value  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"SetPropertyString\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"SetPropertyString\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    Py_INCREF(Py_None);
    result = Py_None;

    return result; 
  } 

  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_Decrypt (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "cipherKeyId",
          "input",
          "iv",
          NULL};

    XbmcCommons::Buffer  cipherKeyId ;
    PyObject* pycipherKeyId = NULL;
    XbmcCommons::Buffer  input ;
    PyObject* pyinput = NULL;
    XbmcCommons::Buffer  iv ;
    PyObject* pyiv = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "OOO",
       const_cast<char**>(keywords),
         &pycipherKeyId,
         &pyinput,
         &pyiv
       ))
    {
      return NULL;
    }

    XbmcCommons::Buffer  apiResult;
    try
    {
      
    if (PyUnicode_Check(pycipherKeyId))
    {
      Py_ssize_t pysize;
      const char* str = PyUnicode_AsUTF8AndSize(pycipherKeyId, &pysize);
      size_t size = static_cast<size_t>(pysize);
      cipherKeyId.allocate(size);
      cipherKeyId.put(str, size);
      cipherKeyId.flip(); // prepare the buffer for reading from
    }
    else if (PyBytes_Check(pycipherKeyId))
    {
      Py_ssize_t pysize = PyBytes_GET_SIZE(pycipherKeyId);
      const char* str = PyBytes_AS_STRING(pycipherKeyId);
      size_t size = static_cast<size_t>(pysize);
      cipherKeyId.allocate(size);
      cipherKeyId.put(str, size);
      cipherKeyId.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pycipherKeyId))
    {
      size_t size = PyByteArray_Size(pycipherKeyId);
      cipherKeyId.allocate(size);
      cipherKeyId.put(PyByteArray_AsString(pycipherKeyId),size);
      cipherKeyId.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string, bytes or a bytearray", "cipherKeyId", "Decrypt"); 
      
    if (PyUnicode_Check(pyinput))
    {
      Py_ssize_t pysize;
      const char* str = PyUnicode_AsUTF8AndSize(pyinput, &pysize);
      size_t size = static_cast<size_t>(pysize);
      input.allocate(size);
      input.put(str, size);
      input.flip(); // prepare the buffer for reading from
    }
    else if (PyBytes_Check(pyinput))
    {
      Py_ssize_t pysize = PyBytes_GET_SIZE(pyinput);
      const char* str = PyBytes_AS_STRING(pyinput);
      size_t size = static_cast<size_t>(pysize);
      input.allocate(size);
      input.put(str, size);
      input.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pyinput))
    {
      size_t size = PyByteArray_Size(pyinput);
      input.allocate(size);
      input.put(PyByteArray_AsString(pyinput),size);
      input.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string, bytes or a bytearray", "input", "Decrypt"); 
      
    if (PyUnicode_Check(pyiv))
    {
      Py_ssize_t pysize;
      const char* str = PyUnicode_AsUTF8AndSize(pyiv, &pysize);
      size_t size = static_cast<size_t>(pysize);
      iv.allocate(size);
      iv.put(str, size);
      iv.flip(); // prepare the buffer for reading from
    }
    else if (PyBytes_Check(pyiv))
    {
      Py_ssize_t pysize = PyBytes_GET_SIZE(pyiv);
      const char* str = PyBytes_AS_STRING(pyiv);
      size_t size = static_cast<size_t>(pysize);
      iv.allocate(size);
      iv.put(str, size);
      iv.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pyiv))
    {
      size_t size = PyByteArray_Size(pyiv);
      iv.allocate(size);
      iv.put(PyByteArray_AsString(pyiv),size);
      iv.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string, bytes or a bytearray", "iv", "Decrypt"); 

      apiResult = ((XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"Decrypt","XBMCAddon::xbmcdrm::CryptoSession"))-> Decrypt(  cipherKeyId,  input,  iv  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"Decrypt\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"Decrypt\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyByteArray_FromStringAndSize((char*)apiResult.curPosition(),apiResult.remaining());

    return result; 
  } 

  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_Encrypt (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "cipherKeyId",
          "input",
          "iv",
          NULL};

    XbmcCommons::Buffer  cipherKeyId ;
    PyObject* pycipherKeyId = NULL;
    XbmcCommons::Buffer  input ;
    PyObject* pyinput = NULL;
    XbmcCommons::Buffer  iv ;
    PyObject* pyiv = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "OOO",
       const_cast<char**>(keywords),
         &pycipherKeyId,
         &pyinput,
         &pyiv
       ))
    {
      return NULL;
    }

    XbmcCommons::Buffer  apiResult;
    try
    {
      
    if (PyUnicode_Check(pycipherKeyId))
    {
      Py_ssize_t pysize;
      const char* str = PyUnicode_AsUTF8AndSize(pycipherKeyId, &pysize);
      size_t size = static_cast<size_t>(pysize);
      cipherKeyId.allocate(size);
      cipherKeyId.put(str, size);
      cipherKeyId.flip(); // prepare the buffer for reading from
    }
    else if (PyBytes_Check(pycipherKeyId))
    {
      Py_ssize_t pysize = PyBytes_GET_SIZE(pycipherKeyId);
      const char* str = PyBytes_AS_STRING(pycipherKeyId);
      size_t size = static_cast<size_t>(pysize);
      cipherKeyId.allocate(size);
      cipherKeyId.put(str, size);
      cipherKeyId.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pycipherKeyId))
    {
      size_t size = PyByteArray_Size(pycipherKeyId);
      cipherKeyId.allocate(size);
      cipherKeyId.put(PyByteArray_AsString(pycipherKeyId),size);
      cipherKeyId.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string, bytes or a bytearray", "cipherKeyId", "Encrypt"); 
      
    if (PyUnicode_Check(pyinput))
    {
      Py_ssize_t pysize;
      const char* str = PyUnicode_AsUTF8AndSize(pyinput, &pysize);
      size_t size = static_cast<size_t>(pysize);
      input.allocate(size);
      input.put(str, size);
      input.flip(); // prepare the buffer for reading from
    }
    else if (PyBytes_Check(pyinput))
    {
      Py_ssize_t pysize = PyBytes_GET_SIZE(pyinput);
      const char* str = PyBytes_AS_STRING(pyinput);
      size_t size = static_cast<size_t>(pysize);
      input.allocate(size);
      input.put(str, size);
      input.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pyinput))
    {
      size_t size = PyByteArray_Size(pyinput);
      input.allocate(size);
      input.put(PyByteArray_AsString(pyinput),size);
      input.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string, bytes or a bytearray", "input", "Encrypt"); 
      
    if (PyUnicode_Check(pyiv))
    {
      Py_ssize_t pysize;
      const char* str = PyUnicode_AsUTF8AndSize(pyiv, &pysize);
      size_t size = static_cast<size_t>(pysize);
      iv.allocate(size);
      iv.put(str, size);
      iv.flip(); // prepare the buffer for reading from
    }
    else if (PyBytes_Check(pyiv))
    {
      Py_ssize_t pysize = PyBytes_GET_SIZE(pyiv);
      const char* str = PyBytes_AS_STRING(pyiv);
      size_t size = static_cast<size_t>(pysize);
      iv.allocate(size);
      iv.put(str, size);
      iv.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pyiv))
    {
      size_t size = PyByteArray_Size(pyiv);
      iv.allocate(size);
      iv.put(PyByteArray_AsString(pyiv),size);
      iv.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string, bytes or a bytearray", "iv", "Encrypt"); 

      apiResult = ((XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"Encrypt","XBMCAddon::xbmcdrm::CryptoSession"))-> Encrypt(  cipherKeyId,  input,  iv  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"Encrypt\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"Encrypt\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyByteArray_FromStringAndSize((char*)apiResult.curPosition(),apiResult.remaining());

    return result; 
  } 

  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_Sign (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "macKeyId",
          "message",
          NULL};

    XbmcCommons::Buffer  macKeyId ;
    PyObject* pymacKeyId = NULL;
    XbmcCommons::Buffer  message ;
    PyObject* pymessage = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "OO",
       const_cast<char**>(keywords),
         &pymacKeyId,
         &pymessage
       ))
    {
      return NULL;
    }

    XbmcCommons::Buffer  apiResult;
    try
    {
      
    if (PyUnicode_Check(pymacKeyId))
    {
      Py_ssize_t pysize;
      const char* str = PyUnicode_AsUTF8AndSize(pymacKeyId, &pysize);
      size_t size = static_cast<size_t>(pysize);
      macKeyId.allocate(size);
      macKeyId.put(str, size);
      macKeyId.flip(); // prepare the buffer for reading from
    }
    else if (PyBytes_Check(pymacKeyId))
    {
      Py_ssize_t pysize = PyBytes_GET_SIZE(pymacKeyId);
      const char* str = PyBytes_AS_STRING(pymacKeyId);
      size_t size = static_cast<size_t>(pysize);
      macKeyId.allocate(size);
      macKeyId.put(str, size);
      macKeyId.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pymacKeyId))
    {
      size_t size = PyByteArray_Size(pymacKeyId);
      macKeyId.allocate(size);
      macKeyId.put(PyByteArray_AsString(pymacKeyId),size);
      macKeyId.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string, bytes or a bytearray", "macKeyId", "Sign"); 
      
    if (PyUnicode_Check(pymessage))
    {
      Py_ssize_t pysize;
      const char* str = PyUnicode_AsUTF8AndSize(pymessage, &pysize);
      size_t size = static_cast<size_t>(pysize);
      message.allocate(size);
      message.put(str, size);
      message.flip(); // prepare the buffer for reading from
    }
    else if (PyBytes_Check(pymessage))
    {
      Py_ssize_t pysize = PyBytes_GET_SIZE(pymessage);
      const char* str = PyBytes_AS_STRING(pymessage);
      size_t size = static_cast<size_t>(pysize);
      message.allocate(size);
      message.put(str, size);
      message.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pymessage))
    {
      size_t size = PyByteArray_Size(pymessage);
      message.allocate(size);
      message.put(PyByteArray_AsString(pymessage),size);
      message.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string, bytes or a bytearray", "message", "Sign"); 

      apiResult = ((XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"Sign","XBMCAddon::xbmcdrm::CryptoSession"))-> Sign(  macKeyId,  message  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"Sign\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"Sign\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = PyByteArray_FromStringAndSize((char*)apiResult.curPosition(),apiResult.remaining());

    return result; 
  } 

  static PyObject* xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_Verify (PyHolder* self  , PyObject *args, PyObject *kwds  )
  {
    XBMC_TRACE;

    static const char *keywords[] = {
          "macKeyId",
          "message",
          "signature",
          NULL};

    XbmcCommons::Buffer  macKeyId ;
    PyObject* pymacKeyId = NULL;
    XbmcCommons::Buffer  message ;
    PyObject* pymessage = NULL;
    XbmcCommons::Buffer  signature ;
    PyObject* pysignature = NULL;
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       "OOO",
       const_cast<char**>(keywords),
         &pymacKeyId,
         &pymessage,
         &pysignature
       ))
    {
      return NULL;
    }

    bool  apiResult;
    try
    {
      
    if (PyUnicode_Check(pymacKeyId))
    {
      Py_ssize_t pysize;
      const char* str = PyUnicode_AsUTF8AndSize(pymacKeyId, &pysize);
      size_t size = static_cast<size_t>(pysize);
      macKeyId.allocate(size);
      macKeyId.put(str, size);
      macKeyId.flip(); // prepare the buffer for reading from
    }
    else if (PyBytes_Check(pymacKeyId))
    {
      Py_ssize_t pysize = PyBytes_GET_SIZE(pymacKeyId);
      const char* str = PyBytes_AS_STRING(pymacKeyId);
      size_t size = static_cast<size_t>(pysize);
      macKeyId.allocate(size);
      macKeyId.put(str, size);
      macKeyId.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pymacKeyId))
    {
      size_t size = PyByteArray_Size(pymacKeyId);
      macKeyId.allocate(size);
      macKeyId.put(PyByteArray_AsString(pymacKeyId),size);
      macKeyId.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string, bytes or a bytearray", "macKeyId", "Verify"); 
      
    if (PyUnicode_Check(pymessage))
    {
      Py_ssize_t pysize;
      const char* str = PyUnicode_AsUTF8AndSize(pymessage, &pysize);
      size_t size = static_cast<size_t>(pysize);
      message.allocate(size);
      message.put(str, size);
      message.flip(); // prepare the buffer for reading from
    }
    else if (PyBytes_Check(pymessage))
    {
      Py_ssize_t pysize = PyBytes_GET_SIZE(pymessage);
      const char* str = PyBytes_AS_STRING(pymessage);
      size_t size = static_cast<size_t>(pysize);
      message.allocate(size);
      message.put(str, size);
      message.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pymessage))
    {
      size_t size = PyByteArray_Size(pymessage);
      message.allocate(size);
      message.put(PyByteArray_AsString(pymessage),size);
      message.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string, bytes or a bytearray", "message", "Verify"); 
      
    if (PyUnicode_Check(pysignature))
    {
      Py_ssize_t pysize;
      const char* str = PyUnicode_AsUTF8AndSize(pysignature, &pysize);
      size_t size = static_cast<size_t>(pysize);
      signature.allocate(size);
      signature.put(str, size);
      signature.flip(); // prepare the buffer for reading from
    }
    else if (PyBytes_Check(pysignature))
    {
      Py_ssize_t pysize = PyBytes_GET_SIZE(pysignature);
      const char* str = PyBytes_AS_STRING(pysignature);
      size_t size = static_cast<size_t>(pysize);
      signature.allocate(size);
      signature.put(str, size);
      signature.flip(); // prepare the buffer for reading from
    }
    else if (PyByteArray_Check(pysignature))
    {
      size_t size = PyByteArray_Size(pysignature);
      signature.allocate(size);
      signature.put(PyByteArray_AsString(pysignature),size);
      signature.flip(); // prepare the buffer for reading from
    }
    else
      throw XBMCAddon::WrongTypeException("argument \"%s\" for \"%s\" must be a string, bytes or a bytearray", "signature", "Verify"); 

      apiResult = ((XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"Verify","XBMCAddon::xbmcdrm::CryptoSession"))-> Verify(  macKeyId,  message,  signature  );

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
      return NULL; 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"Verify\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"Verify\""); 
      return NULL; 
    }

    PyObject* result = Py_None;

    // transform the result
    result = apiResult ? Py_True : Py_False; Py_INCREF(result);

    return result; 
  } 

  static void xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_Dealloc (PyHolder* self  )
  {
    XBMC_TRACE;

    try
    {


      XBMCAddon::xbmcdrm::CryptoSession* theObj = (XBMCAddon::xbmcdrm::CryptoSession*)retrieveApiInstance((PyObject*)self,&TyXBMCAddon_xbmcdrm_CryptoSession_Type,"~XBMCAddon::xbmcdrm::CryptoSession","XBMCAddon::xbmcdrm::CryptoSession");
      cleanForDealloc(theObj);

    }
    catch (const XBMCAddon::WrongTypeException& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_TypeError, e.GetExMessage()); 
    }
    catch (const XbmcCommons::Exception& e)
    {
      CLog::Log(LOGERROR,"EXCEPTION: {}",e.GetExMessage());
      PyErr_SetString(PyExc_RuntimeError, e.GetExMessage()); 
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"EXCEPTION: Unknown exception thrown from the call \"XBMCAddon::xbmcdrm::CryptoSession\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"XBMCAddon::xbmcdrm::CryptoSession\""); 
    }

    (((PyObject*)(self))->ob_type)->tp_free((PyObject*)self);
    
  } 
  //=========================================================================
  // This section contains the initialization for the
  // Python extension for the Api class XBMCAddon::xbmcdrm::CryptoSession
  //=========================================================================
  // All of the methods on this class
  static PyMethodDef XBMCAddon_xbmcdrm_CryptoSession_methods[] = { 
    {"GetKeyRequest", (PyCFunction)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_GetKeyRequest, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"GetPropertyString", (PyCFunction)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_GetPropertyString, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"ProvideKeyResponse", (PyCFunction)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_ProvideKeyResponse, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"RemoveKeys", (PyCFunction)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_RemoveKeys, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"RestoreKeys", (PyCFunction)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_RestoreKeys, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"SetPropertyString", (PyCFunction)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_SetPropertyString, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"Decrypt", (PyCFunction)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_Decrypt, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"Encrypt", (PyCFunction)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_Encrypt, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"Sign", (PyCFunction)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_Sign, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {"Verify", (PyCFunction)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_Verify, METH_VARARGS|METH_KEYWORDS, NULL }, 
    {NULL, NULL, 0, NULL}
  };



  // This method initializes the above mentioned Python Type structure
  static void initPyXBMCAddon_xbmcdrm_CryptoSession_Type()
  {


    PyTypeObject& pythonType = TyXBMCAddon_xbmcdrm_CryptoSession_Type.pythonType;
    pythonType.tp_name = "xbmcdrm.CryptoSession";
    pythonType.tp_basicsize = sizeof(PyHolder);
    pythonType.tp_dealloc = (destructor)xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_Dealloc; 

    pythonType.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;

    pythonType.tp_doc = NULL;
    pythonType.tp_methods = XBMCAddon_xbmcdrm_CryptoSession_methods; 

    pythonType.tp_base = NULL;
    pythonType.tp_new = xbmcdrm_XBMCAddon_xbmcdrm_CryptoSession_New;
    pythonType.tp_init = dummy_tp_init;

    TyXBMCAddon_xbmcdrm_CryptoSession_Type.swigType="p.XBMCAddon::xbmcdrm::CryptoSession";
    registerAddonClassTypeInformation(&TyXBMCAddon_xbmcdrm_CryptoSession_Type);

  }
  //=========================================================================


  static PyMethodDef xbmcdrm_methods[] = { 
    {NULL, NULL, 0, NULL}
  };

  // This is the call that will call all of the other initializes
  //  for all of the classes in this module
  static void initTypes()
  {
    static bool typesAlreadyInitialized = false;
    if (!typesAlreadyInitialized)
    {
      typesAlreadyInitialized = true;

      initPyXBMCAddon_xbmcdrm_CryptoSession_Type();
      if (PyType_Ready(&(TyXBMCAddon_xbmcdrm_CryptoSession_Type.pythonType)) < 0)
        return;
    }
  }

  static struct PyModuleDef createModule
  {
      PyModuleDef_HEAD_INIT,
      "xbmcdrm",
      "",
      -1,
      xbmcdrm_methods,
      nullptr,
      nullptr,
      nullptr,
      nullptr,
  };

  PyObject *PyInit_Module_xbmcdrm()
  {
    initTypes();

    // init general xbmcdrm modules
    PyObject* module;


    Py_INCREF(&(TyXBMCAddon_xbmcdrm_CryptoSession_Type.pythonType));

    module = PyModule_Create(&createModule);
    if (module == NULL) return NULL;


    PyModule_AddObject(module, "CryptoSession", (PyObject*)(&(TyXBMCAddon_xbmcdrm_CryptoSession_Type.pythonType)));

   // constants
   PyModule_AddStringConstant(module, "__author__", "Team Kodi <http://kodi.tv>");
   PyModule_AddStringConstant(module, "__date__", CCompileInfo::GetBuildDate().c_str());
   PyModule_AddStringConstant(module, "__version__", "3.0.1");
   PyModule_AddStringConstant(module, "__credits__", "Team Kodi");
   PyModule_AddStringConstant(module, "__platform__", "ALL");

   // need to handle constants
   // #define constants

  // constexpr constants

  return module;
  }

} // end PythonBindings namespace for python type definitions


