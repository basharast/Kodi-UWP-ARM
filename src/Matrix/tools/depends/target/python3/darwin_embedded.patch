--- a/Lib/os.py
+++ b/Lib/os.py
@@ -599,6 +599,7 @@
         fullname = path.join(dir, file)
         try:
             exec_func(fullname, *argrest)
+            return
         except (FileNotFoundError, NotADirectoryError) as e:
             last_exc = e
         except OSError as e:
--- a/Lib/platform.py
+++ b/Lib/platform.py
@@ -604,7 +604,7 @@
 
     """ Interface to the system's uname command.
     """
-    if sys.platform in ('dos', 'win32', 'win16'):
+    if sys.platform in ('dos', 'win32', 'win16', 'darwin'):
         # XXX Others too ?
         return default
 
@@ -626,7 +626,7 @@
         default in case the command should fail.
 
     """
-    if sys.platform in ('dos', 'win32', 'win16'):
+    if sys.platform in ('dos', 'win32', 'win16', 'darwin'):
         # XXX Others too ?
         return default
 
--- a/Lib/subprocess.py
+++ b/Lib/subprocess.py
@@ -737,6 +737,8 @@
                  restore_signals=True, start_new_session=False,
                  pass_fds=(), *, encoding=None, errors=None, text=None):
         """Create new Popen instance."""
+        raise RuntimeError("Subprocesses are not supported on this platform.")
+
         _cleanup()
         # Held while anything is calling waitpid before returncode has been
         # updated to prevent clobbering returncode if wait() or poll() are
@@ -936,6 +936,7 @@
         if not self._child_created:
             # We didn't get to successfully create a child process.
             return
+        return
         if self.returncode is None:
             # Not reading subprocess exit status creates a zombie process which
             # is only destroyed at the parent python process exit
@@ -1566,6 +1566,7 @@
             else:
                 args = list(args)
 
+            shell = False
             if shell:
                 # On Android the default shell is at '/system/bin/sh'.
                 unix_shell = ('/system/bin/sh' if
@@ -1643,6 +1643,7 @@
                             errpipe_read, errpipe_write,
                             restore_signals, start_new_session, preexec_fn)
                     self._child_created = True
+                    return
                 finally:
                     # be sure the FD is closed no matter what
                     os.close(errpipe_write)
@@ -1662,6 +1662,7 @@
             finally:
                 # be sure the FD is closed no matter what
                 os.close(errpipe_read)
+                return
 
             if errpipe_data:
                 try:
@@ -1721,7 +1724,7 @@
                 raise SubprocessError("Unknown child exit status!")
 
 
-        def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
+        def _internal_poll(self, _deadstate=None, _waitpid=None,
                 _WNOHANG=os.WNOHANG, _ECHILD=errno.ECHILD):
             """Check if child process has terminated.  Returns returncode
             attribute.
@@ -1730,6 +1733,8 @@
             outside of the local scope (nor can any methods it calls).
 
             """
+            if _waitpid is None:
+                _waitpid = os.waitpid
             if self.returncode is None:
                 if not self._waitpid_lock.acquire(False):
                     # Something else is busy calling waitpid.  Don't allow two
--- a/Lib/urllib/request.py
+++ b/Lib/urllib/request.py
@@ -2616,11 +2616,9 @@
 
 
 if sys.platform == 'darwin':
-    from _scproxy import _get_proxy_settings, _get_proxies
 
     def proxy_bypass_macosx_sysconf(host):
-        proxy_settings = _get_proxy_settings()
-        return _proxy_bypass_macosx_sysconf(host, proxy_settings)
+        return False
 
     def getproxies_macosx_sysconf():
         """Return a dictionary of scheme -> proxy server URL mappings.
@@ -2628,7 +2628,7 @@
         This function uses the MacOSX framework SystemConfiguration
         to fetch the proxy information.
         """
-        return _get_proxies()
+        return {}
 
 
 
@@ -2641,9 +2641,9 @@
         """
         proxies = getproxies_environment()
         if proxies:
-            return proxy_bypass_environment(host, proxies)
+            return False
         else:
-            return proxy_bypass_macosx_sysconf(host)
+            return False
 
     def getproxies():
         return getproxies_environment() or getproxies_macosx_sysconf()
--- a/Modules/_posixsubprocess.c
+++ b/Modules/_posixsubprocess.c
@@ -49,6 +49,9 @@
 
 #define POSIX_CALL(call)   do { if ((call) == -1) goto error; } while (0)
 
+#if defined(__APPLE__)
+#include <TargetConditionals.h>
+#endif
 
 /* If gc was disabled, call gc.enable().  Return 0 on success. */
 static int
@@ -419,14 +422,14 @@
         goto error;
 
     /* Close parent's pipe ends. */
-    if (p2cwrite != -1)
+/*    if (p2cwrite != -1)
         POSIX_CALL(close(p2cwrite));
     if (c2pread != -1)
         POSIX_CALL(close(c2pread));
     if (errread != -1)
         POSIX_CALL(close(errread));
     POSIX_CALL(close(errpipe_read));
-
+*/
     /* When duping fds, if there arises a situation where one of the fds is
        either 0, 1 or 2, it is possible that it is overwritten (#12607). */
     if (c2pwrite == 0) {
@@ -471,6 +474,8 @@
     /* We no longer manually close p2cread, c2pwrite, and errwrite here as
      * _close_open_fds takes care when it is not already non-inheritable. */
 
+    const char *currentDir = getcwd(NULL, 0);
+
     if (cwd)
         POSIX_CALL(chdir(cwd));
 
@@ -496,13 +501,13 @@
             errno = 0;  /* We don't want to report an OSError. */
             goto error;
         }
-        /* Py_DECREF(result); - We're about to exec so why bother? */
+        Py_DECREF(result); /* - We're about to exec so why bother? */
     }
 
     /* close FDs after executing preexec_fn, which might open FDs */
     if (close_fds) {
         /* TODO HP-UX could use pstat_getproc() if anyone cares about it. */
-        _close_open_fds(3, py_fds_to_keep);
+//        _close_open_fds(3, py_fds_to_keep);
     }
 
     /* This loop matches the Lib/os.py _execvpe()'s PATH search when */
@@ -511,20 +516,34 @@
     for (i = 0; exec_array[i] != NULL; ++i) {
         const char *executable = exec_array[i];
         if (envp) {
+#if defined(TARGET_OS_TV)
+            saved_errno = ENOTSUP;
+#elif defined(TARGET_OS_IOS)
             execve(executable, argv, envp);
+            saved_errno = execve(executable, argv, envp);
+#endif
+            break;
         } else {
+#if defined(TARGET_OS_TV)
+            saved_errno = ENOTSUP;
+#elif defined(TARGET_OS_IOS)
             execv(executable, argv);
+            saved_errno = execv(executable, argv);
+#endif
+            break;
         }
         if (errno != ENOENT && errno != ENOTDIR && saved_errno == 0) {
             saved_errno = errno;
         }
     }
+    if (saved_errno == 0) return;
     /* Report the first exec error, not the last. */
     if (saved_errno)
         errno = saved_errno;
 
 error:
     saved_errno = errno;
+    chdir(currentDir);
     /* Report the posix error to our parent process. */
     /* We ignore all write() return values as the total size of our writes is
        less than PIPEBUF and we cannot do anything about an error anyways.
@@ -686,11 +705,12 @@
         preexec_fn_args_tuple = PyTuple_New(0);
         if (!preexec_fn_args_tuple)
             goto cleanup;
-        PyOS_BeforeFork();
+//        PyOS_BeforeFork();
         need_after_fork = 1;
     }
 
-    pid = fork();
+    pid = -1;
+    errno = ENOTSUP;
     if (pid == 0) {
         /* Child process */
         /*
@@ -704,7 +724,7 @@
              * This call may not be async-signal-safe but neither is calling
              * back into Python.  The user asked us to use hope as a strategy
              * to avoid deadlock... */
-            PyOS_AfterFork_Child();
+//            PyOS_AfterFork_Child();
         }
 
         child_exec(exec_array, argv, envp, cwd,
@@ -723,8 +743,8 @@
 
     Py_XDECREF(cwd_obj2);
 
-    if (need_after_fork)
-        PyOS_AfterFork_Parent();
+//    if (need_after_fork)
+//        PyOS_AfterFork_Parent();
     if (envp)
         _Py_FreeCharPArray(envp);
     if (argv)
--- a/Modules/getpath.c
+++ b/Modules/getpath.c
@@ -806,8 +806,10 @@
       * will fail if a relative path was used. but in that case,
       * absolutize() should help us out below
       */
-    else if(0 == _NSGetExecutablePath(execpath, &nsexeclength) &&
-            execpath[0] == SEP)
+    char *iospath = Py_GETENV("PYTHONHOME");
+    char *prog = Py_GETENV("PYTHONEXECUTABLE");
+    sprintf(execpath, "%s/bin/%s", iospath, prog);
+    if (execpath[0] == SEP)
     {
         size_t len;
         wchar_t *path = Py_DecodeLocale(execpath, &len);
--- a/Modules/posixmodule.c
+++ b/Modules/posixmodule.c
@@ -196,8 +196,8 @@
 #else
 /* Unix functions that the configure script doesn't check for */
 #ifndef __VXWORKS__
-#define HAVE_EXECV      1
-#define HAVE_FORK       1
+//#define HAVE_EXECV      0
+//#define HAVE_FORK       0
 #if defined(__USLC__) && defined(__SCO_VERSION__)       /* SCO UDK Compiler */
 #define HAVE_FORK1      1
 #endif
@@ -210,8 +210,8 @@
 #define HAVE_KILL       1
 #define HAVE_OPENDIR    1
 #define HAVE_PIPE       1
-#define HAVE_SYSTEM     1
-#define HAVE_WAIT       1
+//#define HAVE_SYSTEM     0
+//#define HAVE_WAIT       0
 #define HAVE_TTYNAME    1
 #endif  /* _MSC_VER */
 #endif  /* ! __WATCOMC__ || __QNX__ */
--- a/Include/intrcheck.h
+++ b/Include/intrcheck.h
@@ -7,13 +7,13 @@
 
 PyAPI_FUNC(int) PyOS_InterruptOccurred(void);
 PyAPI_FUNC(void) PyOS_InitInterrupts(void);
-#ifdef HAVE_FORK
+//#ifdef HAVE_FORK
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03070000
 PyAPI_FUNC(void) PyOS_BeforeFork(void);
 PyAPI_FUNC(void) PyOS_AfterFork_Parent(void);
 PyAPI_FUNC(void) PyOS_AfterFork_Child(void);
 #endif
-#endif
+//#endif
 /* Deprecated, please use PyOS_AfterFork_Child() instead */
 Py_DEPRECATED(3.7) PyAPI_FUNC(void) PyOS_AfterFork(void);
